---
title: "Safe Daegu Flood"
author: "team 7"
format: dashboard
---

```{python}

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

from scipy.stats import uniform
from scipy.stats import norm
from scipy.stats import binom
import scipy.stats as sp
from scipy.stats import t
import scipy.stats as stats
from scipy import stats

import math
from collections import Counter
from scipy.integrate import quad
from scipy.stats import uniform, norm, binom, poisson, expon, gamma, t, chi2, f, beta
from scipy.stats import bernoulli
from scipy.stats import ttest_rel

plt.rcParams['font.family'] = 'Malgun Gothic'
plt.rcParams['axes.unicode_minus'] = False

import plotly.express as px
import plotly.graph_objects as go
import geopandas as gpd
import json 
import folium

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()


# -*- coding: utf-8 -*-
import math
import pandas as pd
from pathlib import Path

# csv로 저장하기
# .to_csv("파일이름.csv", index=False, encoding="utf-8-sig")

```

# \[서론\]

## 최근 대구 침수 피해 및 관련 비대위

```{python}
# 관련 기사 첨부 예정

```

# \[본론\]

## 각 요인별 분석

# 1. 날씨 요인

## 대구시 장마 기간 및 기간 내 총 강수량 분석 (2011\~2024)

```{python}
# 대구시 전체 장마 기간 및 기간 내 총 강수량
rain = pd.read_csv('./data/rain.csv')
rain.info()
rain

```

## 대구시 행정구별 강수량 (2016.01.01\~2025.08.18)

```{python}

rain = pd.read_csv("./data/daegu_rain10years.csv", encoding="cp949" )
# print(df)

# df.info()
# df.describe()
# df.shape

# =========================================================
# 0) 사용자 입력: 네가 가진 강수 CSV 경로 지정
#    (컬럼: 지점, 지점명, 일시, 일강수량(mm))
# =========================================================
# YOUR_RAIN_CSV = "daegu_rain10years.csv"   # <-- 파일명/경로만 바꿔줘

# =========================================================
# 1) 관측소 좌표 CSV 직접 생성
#    - 845/846/860/828: 기상청 연보 표의 도·분 → 10진수 변환값
#    - 991/992: 법정리 대표 좌표(근접 대체값)
# =========================================================
stations = [
    # station_id, name, lat, lon, source_note
    (828, "달성",   35 + 41/60, 128 + 25/60, "KMA 연보(도분)"),
    (845, "대구북구",35 + 54/60, 128 + 35/60, "KMA 연보(도분)"),
    (846, "대구서구",35 + 51/60, 128 + 31/60, "KMA 연보(도분)"),
    (860, "신암",   35 + 53/60, 128 + 37/60, "KMA 연보(도분)"),
    # 아래 두 개는 설치 행정동 대표 좌표(근접치)
    (991, "옥포",   35.794916, 128.440565, "옥포읍 신당리 대표점(주소→좌표)"),
    (992, "하빈",   35.900780, 128.446059, "하빈면 현내리(면민운동장 좌표)"),
]
df_stn = pd.DataFrame(stations, columns=["지점","지점명","lat","lon","좌표출처"])
# df_stn.to_csv("stations_daegu.csv", index=False, encoding="utf-8-sig")

# =========================================================
# 2) 대구 9개 구·군 중심 좌표 CSV 직접 생성 (공개 JSON의 대표점 사용)
# =========================================================
districts = [
    ("중구",   35.86678, 128.59538),
    ("동구",   35.88566, 128.63296),
    ("서구",   35.87465, 128.55109),
    ("남구",   35.84119, 128.58800),
    ("북구",   35.90000, 128.59175),
    ("수성구", 35.85905, 128.62625),
    ("달서구", 35.82569, 128.52403),
    ("달성군", 35.77467, 128.42955),
    ("군위군", 36.16995, 128.64705),  # 2023-07-01 대구 편입
]
df_ctr = pd.DataFrame(districts, columns=["구군","lat","lon"])
# df_ctr.to_csv("daegu_district_centroids.csv", index=False, encoding="utf-8-sig")

# =========================================================
# 3) 강수 데이터 읽기
#    - 인코딩 이슈 있을 수 있어 cp949도 시도
# =========================================================
def read_csv_any(path):
    try:
        return pd.read_csv(path)
    except UnicodeDecodeError:
        return pd.read_csv(path, encoding="cp949")

# rain = read_csv_any(YOUR_RAIN_CSV).copy()

# 컬럼 표준화
rain = rain.rename(columns={"일강수량(mm)":"일강수량"})
rain["일시"] = pd.to_datetime(rain["일시"]).dt.date  # 날짜만

# =========================================================
# 4) Haversine 거리(km)
# =========================================================
def haversine_km(lat1, lon1, lat2, lon2):
    R = 6371.0088
    p1, p2 = math.radians(lat1), math.radians(lat2)
    dphi = math.radians(lat2 - lat1)
    dlmb = math.radians(lon2 - lon1)
    a = math.sin(dphi/2)**2 + math.cos(p1)*math.cos(p2)*math.sin(dlmb/2)**2
    return 2*R*math.asin(math.sqrt(a))

# =========================================================
# 5) IDW 함수 (p=2, k-최근접 사용 권장)
# =========================================================
def idw_estimate(target_lat, target_lon, stations_df, values_series, p=2, k=4):
    # stations_df: (지점, lat, lon)
    # values_series: index=지점, value=해당 지점의 값
    rows = []
    for _, r in stations_df.iterrows():
        sid, slat, slon = r["지점"], r["lat"], r["lon"]
        val = values_series.get(sid, None)
        if pd.notnull(val):
            d = haversine_km(target_lat, target_lon, slat, slon)
            rows.append((sid, d, val))
    if not rows:
        return float("nan")

    # 0거리(같은 점) 보호
    rows = [(sid, max(d, 1e-6), val) for sid, d, val in rows]

    # k-최근접만 사용(너무 먼 지점 영향 제거)
    rows.sort(key=lambda x: x[1])
    rows = rows[:k]

    weights = [1/(d**p) for _, d, _ in rows]
    wsum = sum(weights)
    return sum(w*v for w, (_, _, v) in zip(weights, rows)) / wsum if wsum > 0 else float("nan")

# =========================================================
# 6) 날짜별로 관측소 값 → 각 구·군 IDW 추정
# =========================================================
# 관측소 좌표 테이블
stn_xy = df_stn[["지점","lat","lon"]].drop_duplicates().set_index("지점")

# 일자 × 지점 피벗 (값=일강수량)
pv = rain.pivot_table(index="일시", columns="지점", values="일강수량", aggfunc="mean")

# 결과 담을 리스트
out = []
for the_date, row in pv.iterrows():
    # row: index=지점, value=그 날 지점 값
    for _, g in df_ctr.iterrows():
        gname, glat, glon = g["구군"], g["lat"], g["lon"]
        est = idw_estimate(glat, glon, df_stn[["지점","lat","lon"]], row, p=2, k=4)
        out.append([the_date, gname, est])

df_out = pd.DataFrame(out, columns=["일시","구군","추정_일강수량(mm)"])
df_out = df_out.sort_values(["일시","구군"]).reset_index(drop=True)

# 저장
# df_out.to_csv("대구 행정구별 강수량.csv", index=False, encoding="utf-8-sig")

# 미리보기(앞부분)
print(df_out)
print("\n== 파일 생성 완료 ==")
print(" - 관측소 좌표: stations_daegu.csv")
print(" - 구군 중심:   daegu_district_centroids.csv")
print(" - 결과:        daegu_district_rain_idw.csv")


# df_out.groupby("구군")['추정_일강수량(mm)'].mean()
# df_out.groupby("구군")['추정_일강수량(mm)'].describe()

# 출력

rain_gu_mean = df_out.groupby("구군")['추정_일강수량(mm)'].mean()
# rain_gu_mean
# rain_gu_mean.to_csv("대구 행정구별 강수량 mean.csv", index=False, encoding="utf-8-sig")
rain_gu_describe = df_out.groupby("구군")['추정_일강수량(mm)'].describe()
# rain_gu_describe
# rain_gu_describe.to_csv("대구 행정구별 강수량 describe.csv", index=False, encoding="utf-8-sig")

```

## 행정구별 장마 내 강수량 분석 (2016\~2024)

```{python}
# 장마기간 내 행정구별 연간 강수량 분석

# 출력

rainy_gu = pd.read_csv('./data/장마기간 행정구별 강수량.csv')
# rainy_gu

# rainy_dong = pd.read_csv('./data/장마기간 행정구별 강수량_행정동추가.csv')


```

```{python}
# mapping

# 시각화:
# 지역별 평균 or 지역별 강수량 최댓값

```

# 2. 인구 요인

## (1) 전체 인구 밀도: ① 행정구 ② 읍면동

```{python}
# (1) 4_1_dens ############################################################

# 전처리

# 행정구역별 인구밀도
# https://www.daegu.go.kr/index.do?menu_id=00000253

dens = pd.read_csv('./data/4_1_dens.csv')
dens.info()
dens.head()

dens = dens[dens['읍면동'] != '소계']
# len(dens['행정구'].unique())
```

```{python}

# (1) 읍면동 단위 인구밀도
dens['인구밀도'] = (dens['인구(명)'] / dens['면적(㎢)']).round(2)



# (2) 행정구 단위: 각 행정구의 (총 인구 / 총 면적) 기준 인구밀도
gu_dens = dens[['행정구','인구(명)','면적(㎢)']].groupby(['행정구'])

gu_dens_sum = gu_dens.sum().reset_index().rename(columns={'index': '행정구'})
gu_dens_sum['인구밀도'] = (gu_dens_sum['인구(명)'] / gu_dens_sum['면적(㎢)']).round(2)



## 출력

# 행정구 단위 인구밀도
gu_dens_sum
# gu_dens_sum.to_csv("행정구 전체 인구밀도.csv", index=False, encoding="utf-8-sig")

# 읍면동 단위 인구밀도
dens
# dens.to_csv("읍면동 전체 인구밀도.csv", index=False, encoding="utf-8-sig")

```

```{python}

# (3) sort -> 그래프 시각화

## 대구 전체 읍면동 인구밀도
scaler = MinMaxScaler()
dens['읍면동 인구밀도_norm'] = scaler.fit_transform(dens[['인구밀도']])
# 읍면동 인구밀도 상위 10
dens_sort = dens[['행정구','읍면동','인구(명)','면적(㎢)','인구밀도','읍면동 인구밀도_norm']]
dens_sort.sort_values(['인구밀도'], ascending=False).head(10)
# 읍면동 인구밀도 하위 10
# dens_sort.sort_values(['인구밀도'], ascending=True).head(10)


## 행정구 인구밀도 내림차순
gu_dens_sum.sort_values(['인구밀도'], ascending=False)



## 출력

## 행정구 인구밀도 내림차순
gu_dens_sum.sort_values(['인구밀도'], ascending=False)

# 읍면동 인구밀도 상위 10
dens_sort.sort_values(['인구밀도'], ascending=False).head(10)

```

```{python}

# (4) norm 활용 -> 지도 히트맵?

## 행정구 단위
gu_dens_sum['행정구 인구밀도_norm'] = scaler.fit_transform(gu_dens_sum[['인구밀도']])


## 읍면동 단위

# 구별 리스트
gu_list = dens_sort['행정구'].unique()

# 구별 DataFrame 저장 딕셔너리
gu_dfs = {}

for gu in gu_list:
    gu_df = dens_sort[dens_sort['행정구'] == gu].copy()
    
    # 인구밀도 계산 (NaN 방지)
    gu_df['인구밀도'] = (gu_df['인구(명)'] / gu_df['면적(㎢)']).round(2)
    gu_df['인구밀도'] = gu_df['인구밀도'].fillna(0)
    
    # 정규화 (2D array 형태로 변환)
    gu_df[f'{gu} 인구밀도_norm'] = scaler.fit_transform(gu_df[['인구밀도']])
    
    gu_dfs[gu] = gu_df



## 출력

## 행정구 단위
gu_dens_sum

## 읍면동 단위

# Jung_gu =
gu_dfs['중구'].sort_values(['인구밀도'], ascending=False)
# Dong_gu =
gu_dfs['동구'].sort_values(['인구밀도'], ascending=False)
# Seo_gu =
gu_dfs['서구'].sort_values(['인구밀도'], ascending=False)
# Nam_gu =
gu_dfs['남구'].sort_values(['인구밀도'], ascending=False)
# Buk_gu =
gu_dfs['북구'].sort_values(['인구밀도'], ascending=False)
# Suseong_gu =
gu_dfs['수성구'].sort_values(['인구밀도'], ascending=False)
# Dalseo_gu =
gu_dfs['달서구'].sort_values(['인구밀도'], ascending=False)
# Dalseong_gun =
gu_dfs['달성군'].sort_values(['인구밀도'], ascending=False)
# Gunwi_gun =
gu_dfs['군위군'].sort_values(['인구밀도'], ascending=False)

```

```{python}
# 지도 시각화

# --- 1. 데이터 로드 ---
# CSV 파일의 정확한 9개 컬럼 이름 목록
csv_columns = ['행정구', '읍면동', '인구(명)', '면적(㎢)', '세대수', '통', '리', '반', '인구밀도']

# usecols 옵션으로 필요한 9개 컬럼만 읽어와서 ParserError를 해결합니다.
pop_density_df = pd.read_csv('.\data\읍면동 전체 인구밀도.csv',
    names=csv_columns,  # 컬럼 이름을 강제로 지정
    header=0,           # 첫 번째 줄을 헤더로 사용 (이후 names로 덮어씀)
    usecols=csv_columns # 지정된 컬럼만 사용
)

geo_daegu = gpd.read_file(".\data\hangjeongdong_대구광역시.geojson")
geo_gyeongbuk = gpd.read_file(".\data\hangjeongdong_경상북도.geojson")


# --- 2. 데이터 전처리 및 병합 ---
# 2-1. 지도 데이터(GeoJSON) 준비
geo_gunwi = geo_gyeongbuk[geo_gyeongbuk['adm_nm'].str.contains('경상북도 군위군', na=False)].copy()
geo_merged = pd.concat([geo_daegu, geo_gunwi], ignore_index=True)
geo_merged = gpd.GeoDataFrame(geo_merged, crs=geo_daegu.crs)
geo_merged['adm_nm'] = geo_merged['adm_nm'].str.strip().str.replace('경상북도 군위군', '군위군', regex=False)
geo_merged['읍면동_key'] = geo_merged['adm_nm'].apply(lambda x: x.split(' ')[-1])

# 2-2. 양쪽 데이터의 행정동 이름에서 모든 특수문자와 '동'을 제거하여 형식을 통일합니다.
# (예: '두류1·2동' -> '두류12', '두류1동2동' -> '두류12')
def clean_dong_name(name_series):
    return name_series.str.replace('.', '', regex=False).str.replace('·', '', regex=False).str.replace(',', '', regex=False).str.replace('동', '', regex=False)

geo_merged['읍면동_key'] = clean_dong_name(geo_merged['읍면동_key'])
pop_density_df['읍면동_key'] = clean_dong_name(pop_density_df['읍면동'])


# 2-3. 형식이 통일된 '읍면동_key'를 기준으로 데이터 병합
merged_gdf = geo_merged.merge(pop_density_df, on='읍면동_key')


# --- 3. 지도 시각화 ---
m = folium.Map(location=[35.8714, 128.6014], zoom_start=11)

# [역할 1] 배경색 Choropleth 레이어
folium.Choropleth(
    geo_data=merged_gdf,
    name='인구 밀도',
    data=merged_gdf,
    columns=['읍면동_key', '인구밀도'],
    key_on='feature.properties.읍면동_key',
    fill_color='YlOrRd',
    fill_opacity=0.8,
    line_opacity=0,
    legend_name='인구 밀도 (명/㎢)'
).add_to(m)

# [역할 2] 툴팁, 테두리선, 하이라이트 GeoJson 레이어
tooltip = folium.features.GeoJsonTooltip(
    fields=['읍면동', '인구밀도'],  # 툴팁에는 원래 '읍면동' 이름 표시
    aliases=['행정동:', '인구밀도:'],
    style=("background-color: white; color: #333333; font-family: arial; font-size: 12px; padding: 10px;")
)
highlight_function = lambda x: {'weight': 3, 'color': 'black', 'fillOpacity': 0.5}

folium.GeoJson(
    merged_gdf,
    style_function=lambda x: {'fillColor': 'transparent', 'color': 'black', 'weight': 0.5},
    highlight_function=highlight_function,
    tooltip=tooltip
).add_to(m)

folium.LayerControl().add_to(m)


# --- 4. 파일로 저장 ---
# m.save('대구 전체 인구밀도_map.html')
# print("🎉 모든 문제가 해결된 최종 지도가 '대구 전체 인구밀도_map.html' 파일로 저장되었습니다.")

```

## (2) 위험 취약 연령 인구 밀도: ① 어린이 ② 고령자

```{python}

# (2) 4_2_age ############################################################

# 전처리

# 동·읍·면_연령별_주민등록인구_내국인_전체연령_20250812133656
# https://kosis.daegu.go.kr/statHtml/statHtml.do?orgId=203&tblId=DT_203N100020&lang_mode=ko&vw_cd=MT_OTITLE&list_id=203_B203_05&conn_path=I4

age = pd.read_csv('./data/4_2_age.csv')

age.rename(columns={'행정구역':'행정구',
                    '동읍면': '읍면동'}, 
                    inplace=True)
# age.info()
# age.head()


# 쉼표와 '-' 처리 후 숫자형으로 변환
for col in ['계', '남자', '여자']:
    age[col] = (
        age[col]
        .astype(str)               # 문자열 변환
        .str.replace(',', '', regex=False)  # 쉼표 제거
        .str.strip()               # 앞뒤 공백 제거
        .replace({'': '0', '-': '0'})       # 빈값과 '-'를 0으로
        .astype(int)               # 정수형 변환
    )

# 변환 확인
print(age.info())
print(age.head())




# 연령 필터링
# age['연령'].unique()

# 어린이: 0~14세
child = ['0~4세', '5~9세', '10~14세']
age_child = age[age['연령'].isin(child)]

# 노인: 65세 이상
senior = ['65~69세', '70~74세', '75~79세','80~84세', '85~89세', '90~94세','95~99세', '100세이상']
age_senior = age[age['연령'].isin(senior)]


# 어린이 인구 합계
child_sum = (
    age_child
    .groupby(['행정구', '읍면동'], as_index=False)['계']
    .sum()
    .rename(columns={'계': '어린이수'})
)
# child_sum.info()

# 노인 인구 합계
senior_sum = (
    age_senior
    .groupby(['행정구', '읍면동'], as_index=False)['계']
    .sum()
    .rename(columns={'계': '고령자수'})
)
# senior_sum.info()

```

```{python}

# (1) 구 전체 : ['읍면동'] == '소계'
child_gu = child_sum[child_sum['읍면동'] == '소계'][['행정구','어린이수']]
senior_gu = senior_sum[senior_sum['읍면동'] == '소계'][['행정구','고령자수']]

# dens 데이터와 병합 -> 면적 정보
gu_dens_sum_4_age = gu_dens_sum[['행정구','인구(명)','면적(㎢)','인구밀도']]

age_gu = pd.concat([gu_dens_sum_4_age.set_index(['행정구']),
                    child_gu.set_index(['행정구']),
                    senior_gu.set_index(['행정구'])],
                    axis=1).reset_index()


# 연령별 인구밀도 계산
age_gu['어린이_인구밀도'] = (age_gu['어린이수'] / age_gu['면적(㎢)']).round(2)
age_gu['어린이 인구밀도_norm'] = scaler.fit_transform(age_gu[['어린이_인구밀도']])
age_gu['고령자_인구밀도'] = (age_gu['고령자수'] / age_gu['면적(㎢)']).round(2)
age_gu['고령자 인구밀도_norm'] = scaler.fit_transform(age_gu[['고령자_인구밀도']])
# age_gu
# len(age_gu['행정구'].unique())


## 출력

age_gu
# age_gu.to_csv("어린이 고령자 행정구 인구밀도.csv", index=False, encoding="utf-8-sig")

```

```{python}
# (2) 구 내 동읍면 : ['읍면동'] != '소계'
child_dong = child_sum[child_sum['읍면동'] != '소계']
senior_dong = senior_sum[senior_sum['읍면동'] != '소계']


# dens 데이터와 병합 -> 면적 정보
dong_dens_df = pd.concat(gu_dfs.values(), ignore_index=True)
dong_dens_4_age = dong_dens_df[['행정구','읍면동','인구(명)','면적(㎢)','인구밀도']]
# dong_dens_4_age['읍면동'].unique()

age_dong = pd.concat([dong_dens_4_age.set_index(['행정구','읍면동']),
                    child_dong.set_index(['행정구','읍면동']),
                    senior_dong.set_index(['행정구','읍면동'])],
                    axis=1).reset_index()


# 연령별 인구밀도 계산
age_dong['어린이_인구밀도'] = (age_dong['어린이수'] / age_dong['면적(㎢)']).round(2)
age_dong['어린이 인구밀도_norm'] = scaler.fit_transform(age_dong[['어린이_인구밀도']])
age_dong['고령자_인구밀도'] = (age_dong['고령자수'] / age_dong['면적(㎢)']).round(2)
age_dong['고령자 인구밀도_norm'] = scaler.fit_transform(age_dong[['고령자_인구밀도']])

# age_dong
# len(age_dong['행정구'].unique())
# len(age_dong['읍면동'].unique())


## 출력
# age_dong.to_csv("어린이 고령자 읍면동 인구밀도.csv", index=False, encoding="utf-8-sig")

# Jung_gu = 
age_dong[age_dong['행정구'] == '중구']
# Dong_gu = 
age_dong[age_dong['행정구'] == '동구']
# Seo_gu = 
age_dong[age_dong['행정구'] == '서구']
# Nam_gu = 
age_dong[age_dong['행정구'] == '남구']
# Buk_gu = 
age_dong[age_dong['행정구'] == '북구']
# Suseong_gu = 
age_dong[age_dong['행정구'] == '수성구']
# Dalseo_gu = 
age_dong[age_dong['행정구'] == '달서구']
# Dalseong_gun = 
age_dong[age_dong['행정구'] == '달성군']
# Gunwi_gun = 
age_dong[age_dong['행정구'] == '군위군']

```

```{python}
# (3) sort

## 구
# age_gu.columns
age_gu_child = age_gu[['행정구', '인구(명)', '면적(㎢)', '인구밀도', 
                       '어린이수', '어린이_인구밀도', '어린이 인구밀도_norm']]
age_gu_senior = age_gu[['행정구', '인구(명)', '면적(㎢)', '인구밀도', 
                        '고령자수', '고령자_인구밀도', '고령자 인구밀도_norm']]

## 출력

# 행정구 어린이수 내림차순
age_gu_child.sort_values(['어린이수'], ascending=False)
# 행정구 어린이 인구밀도 내림차순
age_gu_child.sort_values(['어린이_인구밀도'], ascending=False)


# 행정구 고령자수 내림차순
age_gu_senior.sort_values(['고령자수'], ascending=False)
# 행정구 고령자 인구밀도 내림차순
age_gu_senior.sort_values(['고령자_인구밀도'], ascending=False)
```

```{python}
## 동
age_dong_child = age_dong[['행정구', '읍면동', '인구(명)', '면적(㎢)', '인구밀도', 
                           '어린이수', '어린이_인구밀도', '어린이 인구밀도_norm']]
age_dong_senior = age_dong[['행정구', '읍면동', '인구(명)', '면적(㎢)', '인구밀도',
                            '고령자수', '고령자_인구밀도', '고령자 인구밀도_norm']]

## 대구시 전체 동 내 sort 10

age_dong_child.sort_values(['어린이수'], ascending=False).head(10)
age_dong_child.sort_values(['어린이_인구밀도'], ascending=False).head(10)
age_dong_senior.sort_values(['고령자수'], ascending=False).head(10)
age_dong_senior.sort_values(['고령자_인구밀도'], ascending=False).head(10)


## 각 행정구 내 sort
# age_dong.info()
# len(age_dong['행정구'].unique())



## 출력

# 중구: Jung_gu = 
age_dong_child[age_dong_child['행정구'] == '중구'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '중구'].sort_values(['고령자수'], ascending=False)

# 동구: Dong_gu = 
age_dong_child[age_dong_child['행정구'] == '동구'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '동구'].sort_values(['고령자수'], ascending=False)

# 서구: Seo_gu = 
age_dong_child[age_dong_child['행정구'] == '서구'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '서구'].sort_values(['고령자수'], ascending=False)

# 남구: Nam_gu = 
age_dong_child[age_dong_child['행정구'] == '남구'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '남구'].sort_values(['고령자수'], ascending=False)

# 북구: Buk_gu = 
age_dong_child[age_dong_child['행정구'] == '북구'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '북구'].sort_values(['고령자수'], ascending=False)

# 수성구: Suseong_gu = 
age_dong_child[age_dong_child['행정구'] == '수성구'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '수성구'].sort_values(['고령자수'], ascending=False)

# 달서구: Dalseo_gu = 
age_dong_child[age_dong_child['행정구'] == '달서구'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '달서구'].sort_values(['고령자수'], ascending=False)

# 달성군: Dalseong_gun = 
age_dong_child[age_dong_child['행정구'] == '달성군'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '달성군'].sort_values(['고령자수'], ascending=False)

# 군위군: Gunwi_gun = 
age_dong_child[age_dong_child['행정구'] == '군위군'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '군위군'].sort_values(['고령자수'], ascending=False)

```

```{python}
# 지도 시각화

# 어린이 인구밀도


# --- 1. 데이터 로드 ---
# '어린이 밀도.csv' 파일을 읽어옵니다. encoding='cp949'를 추가하여 한글 깨짐을 방지합니다.
pop_density_df = pd.read_csv('.\data\어린이 고령자 읍면동 인구밀도.csv') # <--- 1. 파일 이름 수정


geo_daegu = gpd.read_file(".\data\hangjeongdong_대구광역시.geojson")
geo_gyeongbuk = gpd.read_file(".\data\hangjeongdong_경상북도.geojson")


# --- 2. 데이터 전처리 및 병합 ---
# 2-1. 지도 데이터(GeoJSON) 준비 (기존과 동일)
geo_gunwi = geo_gyeongbuk[geo_gyeongbuk['adm_nm'].str.contains('경상북도 군위군', na=False)].copy()
geo_merged = pd.concat([geo_daegu, geo_gunwi], ignore_index=True)
geo_merged = gpd.GeoDataFrame(geo_merged, crs=geo_daegu.crs)
geo_merged['adm_nm'] = geo_merged['adm_nm'].str.strip().str.replace('경상북도 군위군', '군위군', regex=False)
geo_merged['읍면동_key'] = geo_merged['adm_nm'].apply(lambda x: x.split(' ')[-1])

# 2-2. 양쪽 데이터의 행정동 이름에서 모든 특수문자와 '동'을 제거하여 형식을 통일 (기존과 동일)
def clean_dong_name(name_series):
    return name_series.str.replace('.', '', regex=False).str.replace('·', '', regex=False).str.replace(',', '', regex=False).str.replace('동', '', regex=False)

geo_merged['읍면동_key'] = clean_dong_name(geo_merged['읍면동_key'])
pop_density_df['읍면동_key'] = clean_dong_name(pop_density_df['읍면동'])


# 2-3. 형식이 통일된 '읍면동_key'를 기준으로 데이터 병합
merged_gdf = geo_merged.merge(pop_density_df, on='읍면동_key')


# --- 3. 지도 시각화 ---
m = folium.Map(location=[35.8714, 128.6014], zoom_start=11)

# [역할 1] 배경색 Choropleth 레이어
folium.Choropleth(
    geo_data=merged_gdf,
    name='어린이 인구 밀도', # <--- 2. 이름 수정
    data=merged_gdf,
    columns=['읍면동_key', '어린이_인구밀도'], # <--- 3. 컬럼 수정
    key_on='feature.properties.읍면동_key',
    fill_color='YlOrRd',
    fill_opacity=0.8,
    line_opacity=0,
    legend_name='어린이 인구 밀도 (명/㎢)' # <--- 4. 범례 이름 수정
).add_to(m)

# [역할 2] 툴팁, 테두리선, 하이라이트 GeoJson 레이어
tooltip = folium.features.GeoJsonTooltip(
    fields=['읍면동', '어린이_인구밀도'],  # <--- 5. 툴팁 컬럼 수정
    aliases=['행정동:', '어린이 인구밀도:'], # <--- 6. 툴팁 별명 수정
    style=("background-color: white; color: #333333; font-family: arial; font-size: 12px; padding: 10px;")
)
highlight_function = lambda x: {'weight': 3, 'color': 'black', 'fillOpacity': 0.5}

folium.GeoJson(
    merged_gdf,
    style_function=lambda x: {'fillColor': 'transparent', 'color': 'black', 'weight': 0.5},
    highlight_function=highlight_function,
    tooltip=tooltip
).add_to(m)

folium.LayerControl().add_to(m)


# --- 4. 파일로 저장 ---
# m.save('대구 어린이 인구밀도_map.html') # <--- 7. 저장 파일 이름 수정
# print("🎉 어린이 인구 밀도 지도가 대구 어린이 인구밀도_map.html' 파일로 저장되었습니다.")

```

```{python}
# 지도 시각화

# 고령자 인구밀도


# --- 1. 데이터 로드 ---
# '고령자 인구밀도.csv' 파일을 읽어옵니다. encoding='cp949'를 추가하여 한글 깨짐을 방지합니다.
pop_density_df = pd.read_csv('.\data\어린이 고령자 읍면동 인구밀도.csv')

geo_daegu = gpd.read_file(".\data\hangjeongdong_대구광역시.geojson")
geo_gyeongbuk = gpd.read_file(".\data\hangjeongdong_경상북도.geojson")


# --- 2. 데이터 전처리 및 병합 ---
# 2-1. 지도 데이터(GeoJSON) 준비 (기존과 동일)
geo_gunwi = geo_gyeongbuk[geo_gyeongbuk['adm_nm'].str.contains('경상북도 군위군', na=False)].copy()
geo_merged = pd.concat([geo_daegu, geo_gunwi], ignore_index=True)
geo_merged = gpd.GeoDataFrame(geo_merged, crs=geo_daegu.crs)
geo_merged['adm_nm'] = geo_merged['adm_nm'].str.strip().str.replace('경상북도 군위군', '군위군', regex=False)
geo_merged['읍면동_key'] = geo_merged['adm_nm'].apply(lambda x: x.split(' ')[-1])

# 2-2. 양쪽 데이터의 행정동 이름에서 모든 특수문자와 '동'을 제거하여 형식을 통일 (기존과 동일)
def clean_dong_name(name_series):
    return name_series.str.replace('.', '', regex=False).str.replace('·', '', regex=False).str.replace(',', '', regex=False).str.replace('동', '', regex=False)

geo_merged['읍면동_key'] = clean_dong_name(geo_merged['읍면동_key'])
pop_density_df['읍면동_key'] = clean_dong_name(pop_density_df['읍면동'])


# 2-3. 형식이 통일된 '읍면동_key'를 기준으로 데이터 병합
merged_gdf = geo_merged.merge(pop_density_df, on='읍면동_key')


# --- 3. 지도 시각화 ---
m = folium.Map(location=[35.8714, 128.6014], zoom_start=11)

# [역할 1] 배경색 Choropleth 레이어
folium.Choropleth(
    geo_data=merged_gdf,
    name='고령자 인구 밀도', # <--- 2. 이름 수정
    data=merged_gdf,
    columns=['읍면동_key', '고령자_인구밀도'], # <--- 3. 컬럼 수정
    key_on='feature.properties.읍면동_key',
    fill_color='YlOrRd',
    fill_opacity=0.8,
    line_opacity=0,
    legend_name='고령자 인구 밀도 (명/㎢)' # <--- 4. 범례 이름 수정
).add_to(m)

# [역할 2] 툴팁, 테두리선, 하이라이트 GeoJson 레이어
tooltip = folium.features.GeoJsonTooltip(
    fields=['읍면동', '고령자_인구밀도'],  # <--- 5. 툴팁 컬럼 수정
    aliases=['행정동:', '고령자 인구밀도:'], # <--- 6. 툴팁 별명 수정
    style=("background-color: white; color: #333333; font-family: arial; font-size: 12px; padding: 10px;")
)
highlight_function = lambda x: {'weight': 3, 'color': 'black', 'fillOpacity': 0.5}

folium.GeoJson(
    merged_gdf,
    style_function=lambda x: {'fillColor': 'transparent', 'color': 'black', 'weight': 0.5},
    highlight_function=highlight_function,
    tooltip=tooltip
).add_to(m)

folium.LayerControl().add_to(m)


# --- 4. 파일로 저장 ---
# m.save('대구 고령자 인구밀도_map.html') # <--- 7. 저장 파일 이름 수정
# print("🎉 고령자 인구 밀도 지도가 '대구 고령자 인구밀도_map.html' 파일로 저장되었습니다.")

```

## (3) 외국인 인구 밀도

```{python}
# (3) 4_3_foreign ############################################################
# 동·읍·면별_내·외국인_20250812141415
# https://kosis.daegu.go.kr/statHtml/statHtml.do?orgId=203&tblId=DT_203N100015&lang_mode=ko&vw_cd=MT_OTITLE&list_id=203_B203_05&conn_path=I4

# 전처리

fore = pd.read_csv('./data/4_3_foreign.csv')

for col in ['총인구', '한국인', '외국인']:
    fore[col] = (
        fore[col]
        .astype(str)
        .str.replace(',', '')
        .str.strip()
        .replace('-', '0')
        .astype(int)
    )

fore.rename(columns={'행정구역':'행정구',
                    '동읍면': '읍면동',
                    '총인구': '총 인구(명)',
                    '한국인': '한국인 인구(명)', 
                    '외국인': '외국인 인구(명)'}, 
                    inplace=True)

fore = fore[(fore['행정구'] != '합계') & (fore['성별'] == '계')]

fore.info()
fore.head()


# 행정구별 외국인 인구
fore_gu = fore[fore['읍면동'] == '소계'][['행정구', '총 인구(명)', '외국인 인구(명)']]

# 읍면동별 외국인 인구
fore_dong = fore[fore['읍면동'] != '소계'][['행정구', '읍면동', '총 인구(명)', '외국인 인구(명)']]


```

```{python}

# 외국인 인구 밀도

# (1) 행정구별 외국인 인구 밀도
gu_area = dens.groupby('행정구')[['면적(㎢)']].sum().reset_index()

fore_gu = pd.merge(
    fore_gu,
    gu_area,
    on='행정구',
    how='left'
)

fore_gu['외국인 인구밀도'] = (fore_gu['외국인 인구(명)'] / fore_gu['면적(㎢)']).round(2)
# fore_gu

# (2) 읍면동별 외국인 인구 밀도
dong_area = dens.groupby('읍면동')[['면적(㎢)']].sum().reset_index()

fore_dong = pd.merge(
    fore_dong,
    dong_area,
    on='읍면동',
    how='left'
)

fore_dong['외국인 인구밀도'] = (fore_dong['외국인 인구(명)'] / fore_dong['면적(㎢)']).round(2)
# fore_dong


## 출력

# (1) 행정구별 외국인 인구 밀도
# fore_gu

fore_gu.sort_values(by='외국인 인구밀도', ascending=False)


# (2) 읍면동별 외국인 인구 밀도
# fore_dong

# 읍면동별 외국인 인구 밀도 top 10
fore_gu.sort_values(by='외국인 인구밀도', ascending=False).head(10)


```

```{python}

# 외국인 인구밀도 정규화

# (1) 행정구별 외국인 인구 밀도
fore_gu['외국인 인구밀도_norm'] = scaler.fit_transform(
    fore_gu[['외국인 인구밀도']])



# (2) 읍면동별 외국인 인구 밀도
fore_dong['외국인 인구밀도_norm'] = scaler.fit_transform(
    fore_dong[['외국인 인구밀도']])

# 행정구별로 데이터프레임 분리
# Jung_gu      = 
fore_dong[fore_dong['행정구'] == '중구']
# Dong_gu      = 
fore_dong[fore_dong['행정구'] == '동구']
# Seo_gu       = 
fore_dong[fore_dong['행정구'] == '서구']
# Nam_gu       = 
fore_dong[fore_dong['행정구'] == '남구']
# Buk_gu       = 
fore_dong[fore_dong['행정구'] == '북구']
# Suseong_gu   = 
fore_dong[fore_dong['행정구'] == '수성구']
# Dalseo_gu    = 
fore_dong[fore_dong['행정구'] == '달서구']
# Dalseong_gun = 
fore_dong[fore_dong['행정구'] == '달성군']
# Gunwi_gun    = 
fore_dong[fore_dong['행정구'] == '군위군']



# 출력

# fore_gu.to_csv("행정구 외국인 인구.csv", index=False, encoding="utf-8-sig")
# fore_dong.to_csv("읍면동 외국인 인구.csv", index=False, encoding="utf-8-sig")


```

```{python}
# 지도 시각화

# --- 1. 데이터 로드 ---
# '읍면동 외국인 인구.csv' 파일을 읽어옵니다. encoding='cp949'를 추가하여 한글 깨짐을 방지합니다.
pop_density_df = pd.read_csv('.\data\읍면동 외국인 인구.csv')

geo_daegu = gpd.read_file(".\data\hangjeongdong_대구광역시.geojson")
geo_gyeongbuk = gpd.read_file(".\data\hangjeongdong_경상북도.geojson")


# --- 2. 데이터 전처리 및 병합 ---
# 2-1. 지도 데이터(GeoJSON) 준비 (기존과 동일)
geo_gunwi = geo_gyeongbuk[geo_gyeongbuk['adm_nm'].str.contains('경상북도 군위군', na=False)].copy()
geo_merged = pd.concat([geo_daegu, geo_gunwi], ignore_index=True)
geo_merged = gpd.GeoDataFrame(geo_merged, crs=geo_daegu.crs)
geo_merged['adm_nm'] = geo_merged['adm_nm'].str.strip().str.replace('경상북도 군위군', '군위군', regex=False)
geo_merged['읍면동_key'] = geo_merged['adm_nm'].apply(lambda x: x.split(' ')[-1])

# 2-2. 양쪽 데이터의 행정동 이름에서 모든 특수문자와 '동'을 제거하여 형식을 통일 (기존과 동일)
def clean_dong_name(name_series):
    return name_series.str.replace('.', '', regex=False).str.replace('·', '', regex=False).str.replace(',', '', regex=False).str.replace('동', '', regex=False)

geo_merged['읍면동_key'] = clean_dong_name(geo_merged['읍면동_key'])
pop_density_df['읍면동_key'] = clean_dong_name(pop_density_df['읍면동'])


# 2-3. 형식이 통일된 '읍면동_key'를 기준으로 데이터 병합
merged_gdf = geo_merged.merge(pop_density_df, on='읍면동_key')


# --- 3. 지도 시각화 ---
m = folium.Map(location=[35.8714, 128.6014], zoom_start=11)

# [역할 1] 배경색 Choropleth 레이어
folium.Choropleth(
    geo_data=merged_gdf,
    name='외국인 인구 밀도',
    data=merged_gdf,
    columns=['읍면동_key', '외국인 인구밀도'],
    key_on='feature.properties.읍면동_key',
    fill_color='YlOrRd',  # <--- 색상 스케일 원복
    fill_opacity=0.8,
    line_opacity=0,
    legend_name='외국인 인구 밀도 (명/㎢)'
).add_to(m)

# [역할 2] 툴팁, 테두리선, 하이라이트 GeoJson 레이어
tooltip = folium.features.GeoJsonTooltip(
    fields=['읍면동', '외국인 인구밀도'],
    aliases=['행정동:', '외국인 인구밀도:'],
    style=("background-color: white; color: #333333; font-family: arial; font-size: 12px; padding: 10px;")
)
highlight_function = lambda x: {'weight': 3, 'color': 'black', 'fillOpacity': 0.5}

folium.GeoJson(
    merged_gdf,
    style_function=lambda x: {'fillColor': 'transparent', 'color': 'black', 'weight': 0.5},
    highlight_function=highlight_function,
    tooltip=tooltip
).add_to(m)

folium.LayerControl().add_to(m)


# --- 4. 파일로 저장 ---
# m.save('대구 외국인 인구밀도_map.html')
# print("🎉 외국인 인구 밀도 지도가 '대구 외국인 인구밀도_map.html' 파일로 저장되었습니다.")

```

## () 우선대응 필요: 인구밀도 상위 20% + 고령자수 상위 30%

```{python}
# dens.info()
# age.info()
# fore.info()


# 1) 데이터 전처리
age['계'] = pd.to_numeric(age['계'], errors='coerce')
age['연령'] = age['연령'].astype(str)

fore['총 인구(명)'] = pd.to_numeric(fore['총 인구(명)'], errors='coerce')
fore['외국인 인구(명)'] = pd.to_numeric(fore['외국인 인구(명)'], errors='coerce')

# 2) 고령자(65세 이상) 추출 및 읍면동별 합산
# age_65 = age[age['연령'].str.contains(r'^(65|70|75|80|85|90|95|100)', regex=True)]
age_65 = age[age['연령'].str.contains(r'^65|^70|^75|^80|^85|^90|^95|^100')]

age_65_sum = (
    age_65.groupby(['행정구', '읍면동'])['계']
    .sum()
    .reset_index()
    .rename(columns={'계': '고령자수'})
)

# 3) 외국인 비율 계산 (읍면동별)
fore_sum = (
    fore.groupby(['행정구', '읍면동'], as_index=False)[['총 인구(명)', '외국인 인구(명)']].sum()
)
fore_sum['외국인비율'] = fore_sum['외국인 인구(명)'] / fore_sum['총 인구(명)']

# 4) dens와 병합 (읍면동 단위)
# 필요시 '소계' 등 합계 행 제거
dens_clean = dens[~dens['읍면동'].str.contains('소계|합계')]

df_merge = dens_clean.merge(age_65_sum, on=['행정구', '읍면동'], how='left')
df_merge = df_merge.merge(fore_sum[['행정구', '읍면동', '외국인비율']], on=['행정구', '읍면동'], how='left')

# 5) 결측치 처리
df_merge['고령자수'] = df_merge['고령자수'].fillna(0).astype(int)
df_merge['외국인비율'] = df_merge['외국인비율'].fillna(0)

# 6) 우선 대응 지역 조건
pop_density_thresh = df_merge['인구밀도'].quantile(0.8)
elderly_thresh = df_merge['고령자수'].quantile(0.7)
# foreign_thresh = 0.5

priority_areas = df_merge[
    (df_merge['인구밀도'] >= pop_density_thresh) &
    (df_merge['고령자수'] >= elderly_thresh) ]
    # (df_merge['외국인비율'] >= foreign_thresh)

# 7) 결과 출력
print("우선 대응 필요 읍면동:")
print(priority_areas[['행정구', '읍면동', '인구밀도', '고령자수']])


```

## () 고위험 top 10: 인구밀도40% + 고령자40% + 외국인20%

```{python}

# 결측치 처리
df_merge['고령자수'] = df_merge['고령자수'].fillna(0)
df_merge['외국인비율'] = df_merge['외국인비율'].fillna(0)

df_merge.columns

# 사용할 컬럼 추출
risk_df = df_merge[['행정구', '읍면동', '인구밀도', '고령자수', '외국인비율']].copy()

# inf 값 → NaN 변환
risk_df[['인구밀도', '고령자수', '외국인비율']] = risk_df[['인구밀도', '고령자수', '외국인비율']].replace([np.inf, -np.inf], np.nan)

# NaN 채우기 (예: 0으로 채움, 또는 평균/중앙값으로)
risk_df = risk_df.fillna(0)


# 정규화 (Min-Max scaling)
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()
risk_df[['인구밀도_norm', '고령자수_norm', '외국인비율_norm']] = scaler.fit_transform(
    risk_df[['인구밀도', '고령자수', '외국인비율']])


# 가중치 지정
weights = {
    '인구밀도_norm': 0.4,
    '고령자수_norm': 0.4,
    '외국인비율_norm': 0.2
}

# 위험도 점수 계산
risk_df['위험도점수'] = (
    risk_df['인구밀도_norm'] * weights['인구밀도_norm'] +
    risk_df['고령자수_norm'] * weights['고령자수_norm'] +
    risk_df['외국인비율_norm'] * weights['외국인비율_norm']
)

# 위험도 점수 상위 10개 지역 출력
top_risk_areas = risk_df.sort_values(by='위험도점수', ascending=False).head(10)

print(top_risk_areas[['행정구', '읍면동', '위험도점수']])

```

# 3. 지리적 요인

```{python}
# 지도 전처리


#########################################################################
# 1. 행정동 GeoJSON 불러오기
# -----------------------------------------------------------------------
geo = gpd.read_file("./data/hangjeongdong_대구광역시.geojson")
geo2 = gpd.read_file("./data/hangjeongdong_경상북도.geojson")

# 군위 데이터 추출
geo1 = geo2[geo2['adm_nm'].str.contains('경상북도 군위', na=False)].copy()

# 대구 + 군위 합치기
geo_merged = pd.concat([geo, geo1], ignore_index=True)
geo_merged = gpd.GeoDataFrame(geo_merged, crs=geo.crs)

#########################################################################
# 2. 인구밀도 CSV 불러오기
# -----------------------------------------------------------------------
pop = dens
# '행정구'와 '읍면동'을 합쳐 'adm_nm' 임시 생성
pop['adm_nm'] = pop['행정구'] + " " + pop['읍면동']

#########################################################################
# ✨ [수정 1] 데이터 병합 전, KEY 값(adm_nm) 통일
# -----------------------------------------------------------------------
# 1. 양쪽 데이터의 불필요한 앞뒤 공백 제거
geo_merged['adm_nm'] = geo_merged['adm_nm'].str.strip()
pop['adm_nm'] = pop['adm_nm'].str.strip()

# 2. GeoJSON의 '경상북도 군위군'을 '군위군'으로 변경 (대구 편입 반영)
geo_merged['adm_nm'] = geo_merged['adm_nm'].str.replace('경상북도 군위군', '군위군', regex=False)

# 3. 인구 데이터의 'adm_nm'을 GeoJSON 형식('대구광역시 OO구 OO동')과 일치시키기
# 군위군은 '대구광역시'를 붙이지 않도록 예외 처리
is_gunwi = pop['행정구'] == '군위군'
pop.loc[~is_gunwi, 'adm_nm'] = '대구광역시 ' + pop.loc[~is_gunwi, 'adm_nm']



```

## (1) 빗물펌프장 위치

```{python}

# 빗물펌프장 데이터

# --- 1. 데이터 로드 ---
# 행정동 GeoJSON
geo_daegu = gpd.read_file(".\data\hangjeongdong_대구광역시.geojson")
geo_gyeongbuk = gpd.read_file(".\data\hangjeongdong_경상북도.geojson")

# 빗물펌프장 정보 CSV (쉼표로 구분된 파일)
pump_df = pd.read_csv('.\data\빗물펌프장final.csv', sep=',')

# --- 2. 데이터 전처리 ---
# 행정동 데이터 준비
geo_gunwi = geo_gyeongbuk[geo_gyeongbuk['adm_nm'].str.contains('경상북도 군위군', na=False)].copy()
geo_merged = pd.concat([geo_daegu, geo_gunwi], ignore_index=True)
geo_merged = gpd.GeoDataFrame(geo_merged, crs=geo_daegu.crs)
geo_merged['adm_nm'] = geo_merged['adm_nm'].str.strip().str.replace('경상북도 군위군', '군위군', regex=False)

# 펌프장 데이터 준비
pump_df.dropna(subset=['설치년도', '위도 (Latitude)', '경도 (Longitude)'], inplace=True)
pump_df['설치년도'] = pd.to_numeric(pump_df['설치년도'], errors='coerce')

# 펌프장 위치 데이터(GeoDataFrame) 생성 및 좌표계 통일
pump_gdf = gpd.GeoDataFrame(
    pump_df,
    geometry=gpd.points_from_xy(pump_df['경도 (Longitude)'], pump_df['위도 (Latitude)']),
    crs="EPSG:4326"
).to_crs(geo_merged.crs)

# 공간 결합으로 행정동별 펌프장 정보 집계
pump_join = gpd.sjoin(pump_gdf, geo_merged, how="left", predicate="within")

# ======================== ✨ 핵심 수정 부분 ✨ ========================
# 1. 행정동별 '가장 오래된 설치년도' 찾기
oldest_pump = pump_join.groupby("adm_nm")['설치년도'].min().reset_index()
oldest_pump.rename(columns={'설치년도': 'oldest_pump_year'}, inplace=True)

# 2. 현재 연도 기준 '경과년수'를 위험 점수로 변환 (오래될수록 점수가 높음)
current_year = pd.to_datetime('today').year
oldest_pump['risk_score'] = current_year - oldest_pump['oldest_pump_year']
# ======================================================================

# 3. 행정동별 펌프장 상세 정보 문자열 생성 (툴팁용)
def format_pump_details(df_group):
    details = [f"{row['펌프장명']} ({int(row['설치년도'])}년)" for idx, row in df_group.iterrows()]
    return '<br>'.join(details)
pump_details = pump_join.groupby("adm_nm").apply(format_pump_details).reset_index(name="pump_details")

# --- 3. 최종 데이터 통합 ---
df = geo_merged.merge(oldest_pump, on="adm_nm", how="left")
df = df.merge(pump_details, on="adm_nm", how="left")
df['risk_score'].fillna(0, inplace=True) # 펌프장 없는 지역은 0점
df['pump_details'].fillna("펌프장 정보 없음", inplace=True)
df['oldest_pump_year'].fillna("없음", inplace=True)


# --- 4. 지도 시각화 ---
m = folium.Map(location=[35.87, 128.6], zoom_start=11)

# [역할 1] 배경색 Choropleth 레이어 (위험 점수 기준)
folium.Choropleth(
    geo_data=df,
    data=df,
    columns=["adm_nm", "risk_score"],
    key_on="feature.properties.adm_nm",
    fill_color="YlOrRd",
    fill_opacity=0.7,
    line_opacity=0.5,
    legend_name="가장 오래된 펌프장의 경과년수 (높을수록 위험)"
).add_to(m)

# [역할 2] 툴팁, 테두리선, 하이라이트 GeoJson 레이어
tooltip = folium.features.GeoJsonTooltip(
    fields=['adm_nm', 'risk_score', 'pump_details'],
    aliases=['<b>행정동:</b>', '<b>최고 경과년수:</b>', '<b>설치된 펌프장:</b>'],
    style=("background-color: white; color: #333333; font-family: arial; font-size: 12px; padding: 10px;"),
    sticky=True
)

folium.GeoJson(
    df,
    style_function=lambda x: {'fillColor': 'transparent', 'color': 'transparent', 'weight': 0.5},
    highlight_function=lambda x: {'color': 'black', 'weight': 2},
    tooltip=tooltip
).add_to(m)

folium.LayerControl().add_to(m)

# m.save("대구_펌프장_최고노후도_지도.html")
# print("지도 생성이 완료되었습니다: 대구_펌프장_최고노후도_지도.html")


```

## (2) 하천 인근 지역

```{python}
# 저지대 기준 적용 -> 저지대 도출

# --- 1. 데이터 로드 ---
# 침수 위험 지역 목록 CSV
hazard_df = pd.read_csv('.\data\대구_침수위험지역_하천 포함2_좌표.csv')

# 행정구역 경계(GeoJSON) 데이터
geo_daegu = gpd.read_file(".\data\hangjeongdong_대구광역시.geojson")
geo_gyeongbuk = gpd.read_file(".\data\hangjeongdong_경상북도.geojson")


# --- 2. 데이터 준비 ---
# 군위군 데이터를 대구시에 병합
geo_gunwi = geo_gyeongbuk[geo_gyeongbuk['adm_nm'].str.contains('경상북도 군위군', na=False)].copy()
geo_merged = pd.concat([geo_daegu, geo_gunwi], ignore_index=True)
geo_merged = gpd.GeoDataFrame(geo_merged, crs=geo_daegu.crs)
geo_merged['adm_nm'] = geo_merged['adm_nm'].str.strip().str.replace('경상북도 군위군', '군위군', regex=False)


# --- 3. 위험 점수 생성 ---
# 위험 지역 목록에 있는 행정동 이름을 리스트로 만듭니다.
# '대구광역시'를 추가하여 geo_merged의 이름 형식과 통일합니다.
hazard_list = ['대구광역시 ' + name for name in hazard_df['행정구역']]
gunwi_list = [name for name in hazard_df['행정구역'] if '군위군' in name]
hazard_list.extend(gunwi_list)


# geo_merged 데이터프레임에 'risk_score' 컬럼을 추가합니다.
# 위험 지역 목록에 포함되어 있으면 1점, 아니면 0점을 부여합니다.
geo_merged['risk_score'] = geo_merged['adm_nm'].apply(lambda x: 1 if x in hazard_list else 0)


# --- 4. 지도 시각화 ---
m = folium.Map(location=[35.8714, 128.6014], zoom_start=11)

# [역할 1] 배경색 Choropleth 레이어
folium.Choropleth(
    geo_data=geo_merged,
    data=geo_merged,
    columns=['adm_nm', 'risk_score'],
    key_on='feature.properties.adm_nm',
    fill_color='YlOrRd',
    fill_opacity=0.7,
    line_opacity=0.5,
    legend_name='침수 위험도 (1: 위험 지역)'
).add_to(m)

# [역할 2] 툴팁 및 경계선 표시
tooltip = folium.features.GeoJsonTooltip(
    fields=['adm_nm'],
    aliases=['행정동:'],
    style=("background-color: white; color: #333333; font-family: arial; font-size: 12px; padding: 10px;")
)

folium.GeoJson(
    geo_merged,
    style_function=lambda x: {
        'fillOpacity': 0,
        'color': 'black',
        'weight': 0.5
    },
    tooltip=tooltip
).add_to(m)


# --- 5. 저장 ---
folium.LayerControl().add_to(m)
# m.save('하천 인근 지역_map.html')
# print("🎉 침수 위험 지역이 색상으로 표시된 지도가 '하천 인근 지역_map.html' 파일로 저장되었습니다.")

```

# \[결론\]

```{python}
# 동일가중치 -> 종합점수 -> 시각화
# 가중치는 탭 하나 해서 조절 가능하게

```

```{python}
# 위험점수 높은지역/낮은지역 구분 -> 지역별로 비교분석
# 위험도 점수 히스토그램 -> 낮은지역, 높은지역 뽑아서 비교
# 비교: 각 인자별로 어떤 특성때문에 점수가 낮/높게 나오는지



# + 대구시 지리, 인구, 날씨 외 다른 요인이 있을 수 있으니까, 침수 위험이 높은 지역 기준으로
# 기사 등등등 기타 중요 요인 찾아보기 -> 해결책 제시/도출(해결책은 구체적이지 않아도 ~~~ 방안이 있을 것이다 제시)
```

## 과거 재난 지역 대비

-\> (결론단계에서 사용 예정)

데이터 분석을 통한 위험지역 도출 후 실제 위험지역과 대비를 통한 검증 데이터로 활용 예정

```{python}
pd.read_csv('./data/대구광역시_재해위험지구_통합.csv', encoding='cp949')


# 실제 침수 데이터랑 매칭이 되는지 점검 -> 동으로 분석 진행(예정)
```