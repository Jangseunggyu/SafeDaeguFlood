---
title: "Safe Daegu Flood"
author: "team 7"
format: dashboard
---

```{python}

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

from scipy.stats import uniform
from scipy.stats import norm
from scipy.stats import binom
import scipy.stats as sp
from scipy.stats import t
import scipy.stats as stats
from scipy import stats

import math
from collections import Counter
from scipy.integrate import quad
from scipy.stats import uniform, norm, binom, poisson, expon, gamma, t, chi2, f, beta
from scipy.stats import bernoulli
from scipy.stats import ttest_rel

plt.rcParams['font.family'] = 'Malgun Gothic'
plt.rcParams['axes.unicode_minus'] = False

import plotly.express as px
import plotly.graph_objects as go
import geopandas as gpd
import json 
import folium

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()


# -*- coding: utf-8 -*-
import math
import pandas as pd
from pathlib import Path

# csv로 저장하기
# .to_csv("파일이름.csv", index=False, encoding="utf-8-sig")

```

# \[서론\]

## 최근 대구 침수 피해 및 관련 비대위

```{python}
# 관련 기사 첨부 예정

```

# \[본론\]

## 각 요인별 분석

# 1. 날씨 요인

## 대구시 장마 기간 및 기간 내 총 강수량 분석

```{python}
# 대구시 전체 장마 기간 및 기간 내 총 강수량
rain = pd.read_csv('./data/rain.csv')
rain.info()
rain

```

## 대구시 행정구별 강수량 (2016.01.01\~2025.08.18)

```{python}

rain = pd.read_csv("./data/daegu_rain10years.csv", encoding="cp949" )
# print(df)

# df.info()
# df.describe()
# df.shape

# =========================================================
# 0) 사용자 입력: 네가 가진 강수 CSV 경로 지정
#    (컬럼: 지점, 지점명, 일시, 일강수량(mm))
# =========================================================
# YOUR_RAIN_CSV = "daegu_rain10years.csv"   # <-- 파일명/경로만 바꿔줘

# =========================================================
# 1) 관측소 좌표 CSV 직접 생성
#    - 845/846/860/828: 기상청 연보 표의 도·분 → 10진수 변환값
#    - 991/992: 법정리 대표 좌표(근접 대체값)
# =========================================================
stations = [
    # station_id, name, lat, lon, source_note
    (828, "달성",   35 + 41/60, 128 + 25/60, "KMA 연보(도분)"),
    (845, "대구북구",35 + 54/60, 128 + 35/60, "KMA 연보(도분)"),
    (846, "대구서구",35 + 51/60, 128 + 31/60, "KMA 연보(도분)"),
    (860, "신암",   35 + 53/60, 128 + 37/60, "KMA 연보(도분)"),
    # 아래 두 개는 설치 행정동 대표 좌표(근접치)
    (991, "옥포",   35.794916, 128.440565, "옥포읍 신당리 대표점(주소→좌표)"),
    (992, "하빈",   35.900780, 128.446059, "하빈면 현내리(면민운동장 좌표)"),
]
df_stn = pd.DataFrame(stations, columns=["지점","지점명","lat","lon","좌표출처"])
df_stn.to_csv("stations_daegu.csv", index=False, encoding="utf-8-sig")

# =========================================================
# 2) 대구 9개 구·군 중심 좌표 CSV 직접 생성 (공개 JSON의 대표점 사용)
# =========================================================
districts = [
    ("중구",   35.86678, 128.59538),
    ("동구",   35.88566, 128.63296),
    ("서구",   35.87465, 128.55109),
    ("남구",   35.84119, 128.58800),
    ("북구",   35.90000, 128.59175),
    ("수성구", 35.85905, 128.62625),
    ("달서구", 35.82569, 128.52403),
    ("달성군", 35.77467, 128.42955),
    ("군위군", 36.16995, 128.64705),  # 2023-07-01 대구 편입
]
df_ctr = pd.DataFrame(districts, columns=["구군","lat","lon"])
df_ctr.to_csv("daegu_district_centroids.csv", index=False, encoding="utf-8-sig")

# =========================================================
# 3) 강수 데이터 읽기
#    - 인코딩 이슈 있을 수 있어 cp949도 시도
# =========================================================
def read_csv_any(path):
    try:
        return pd.read_csv(path)
    except UnicodeDecodeError:
        return pd.read_csv(path, encoding="cp949")

# rain = read_csv_any(YOUR_RAIN_CSV).copy()

# 컬럼 표준화
rain = rain.rename(columns={"일강수량(mm)":"일강수량"})
rain["일시"] = pd.to_datetime(rain["일시"]).dt.date  # 날짜만

# =========================================================
# 4) Haversine 거리(km)
# =========================================================
def haversine_km(lat1, lon1, lat2, lon2):
    R = 6371.0088
    p1, p2 = math.radians(lat1), math.radians(lat2)
    dphi = math.radians(lat2 - lat1)
    dlmb = math.radians(lon2 - lon1)
    a = math.sin(dphi/2)**2 + math.cos(p1)*math.cos(p2)*math.sin(dlmb/2)**2
    return 2*R*math.asin(math.sqrt(a))

# =========================================================
# 5) IDW 함수 (p=2, k-최근접 사용 권장)
# =========================================================
def idw_estimate(target_lat, target_lon, stations_df, values_series, p=2, k=4):
    # stations_df: (지점, lat, lon)
    # values_series: index=지점, value=해당 지점의 값
    rows = []
    for _, r in stations_df.iterrows():
        sid, slat, slon = r["지점"], r["lat"], r["lon"]
        val = values_series.get(sid, None)
        if pd.notnull(val):
            d = haversine_km(target_lat, target_lon, slat, slon)
            rows.append((sid, d, val))
    if not rows:
        return float("nan")

    # 0거리(같은 점) 보호
    rows = [(sid, max(d, 1e-6), val) for sid, d, val in rows]

    # k-최근접만 사용(너무 먼 지점 영향 제거)
    rows.sort(key=lambda x: x[1])
    rows = rows[:k]

    weights = [1/(d**p) for _, d, _ in rows]
    wsum = sum(weights)
    return sum(w*v for w, (_, _, v) in zip(weights, rows)) / wsum if wsum > 0 else float("nan")

# =========================================================
# 6) 날짜별로 관측소 값 → 각 구·군 IDW 추정
# =========================================================
# 관측소 좌표 테이블
stn_xy = df_stn[["지점","lat","lon"]].drop_duplicates().set_index("지점")

# 일자 × 지점 피벗 (값=일강수량)
pv = rain.pivot_table(index="일시", columns="지점", values="일강수량", aggfunc="mean")

# 결과 담을 리스트
out = []
for the_date, row in pv.iterrows():
    # row: index=지점, value=그 날 지점 값
    for _, g in df_ctr.iterrows():
        gname, glat, glon = g["구군"], g["lat"], g["lon"]
        est = idw_estimate(glat, glon, df_stn[["지점","lat","lon"]], row, p=2, k=4)
        out.append([the_date, gname, est])

df_out = pd.DataFrame(out, columns=["일시","구군","추정_일강수량(mm)"])
df_out = df_out.sort_values(["일시","구군"]).reset_index(drop=True)

# 저장
# df_out.to_csv("대구 행정구별 강수량.csv", index=False, encoding="utf-8-sig")

# 미리보기(앞부분)
print(df_out)
print("\n== 파일 생성 완료 ==")
print(" - 관측소 좌표: stations_daegu.csv")
print(" - 구군 중심:   daegu_district_centroids.csv")
print(" - 결과:        daegu_district_rain_idw.csv")


# df_out.groupby("구군")['추정_일강수량(mm)'].mean()
# df_out.groupby("구군")['추정_일강수량(mm)'].describe()

# 출력

rain_gu_mean = df_out.groupby("구군")['추정_일강수량(mm)'].mean()
rain_gu_mean
# rain_gu_mean.to_csv("대구 행정구별 강수량 mean.csv", index=False, encoding="utf-8-sig")
rain_gu_describe = df_out.groupby("구군")['추정_일강수량(mm)'].describe()
rain_gu_describe
# rain_gu_describe.to_csv("대구 행정구별 강수량 describe.csv", index=False, encoding="utf-8-sig")

```

```{python}
# 장마기간 내 행정구별 연간 강수량 분석

```

```{python}
# mapping

# 시각화:
# 지역별 평균 or 지역별 강수량 최댓값

```

# 2. 인구 요인

## (1) 전체 인구 밀도: ① 행정구 ② 읍면동

```{python}
# (1) 4_1_dens ############################################################

# 전처리

# 행정구역별 인구밀도
# https://www.daegu.go.kr/index.do?menu_id=00000253

dens = pd.read_csv('./data/4_1_dens.csv')
dens.info()
dens.head()

dens = dens[dens['읍면동'] != '소계']
# len(dens['행정구'].unique())
```

```{python}

# (1) 읍면동 단위 인구밀도
dens['인구밀도'] = (dens['인구(명)'] / dens['면적(㎢)']).round(2)



# (2) 행정구 단위: 각 행정구의 (총 인구 / 총 면적) 기준 인구밀도
gu_dens = dens[['행정구','인구(명)','면적(㎢)']].groupby(['행정구'])

gu_dens_sum = gu_dens.sum().reset_index().rename(columns={'index': '행정구'})
gu_dens_sum['인구밀도'] = (gu_dens_sum['인구(명)'] / gu_dens_sum['면적(㎢)']).round(2)



## 출력

# 행정구 단위 인구밀도
gu_dens_sum
# gu_dens_sum.to_csv("행정구 전체 인구밀도.csv", index=False, encoding="utf-8-sig")

# 읍면동 단위 인구밀도
dens
# dens.to_csv("읍면동 전체 인구밀도.csv", index=False, encoding="utf-8-sig")

```

```{python}

# (3) sort -> 그래프 시각화

## 대구 전체 읍면동 인구밀도
scaler = MinMaxScaler()
dens['읍면동 인구밀도_norm'] = scaler.fit_transform(dens[['인구밀도']])
# 읍면동 인구밀도 상위 10
dens_sort = dens[['행정구','읍면동','인구(명)','면적(㎢)','인구밀도','읍면동 인구밀도_norm']]
dens_sort.sort_values(['인구밀도'], ascending=False).head(10)
# 읍면동 인구밀도 하위 10
# dens_sort.sort_values(['인구밀도'], ascending=True).head(10)


## 행정구 인구밀도 내림차순
gu_dens_sum.sort_values(['인구밀도'], ascending=False)



## 출력

## 행정구 인구밀도 내림차순
gu_dens_sum.sort_values(['인구밀도'], ascending=False)

# 읍면동 인구밀도 상위 10
dens_sort.sort_values(['인구밀도'], ascending=False).head(10)

```

```{python}

# (4) norm 활용 -> 지도 히트맵?

## 행정구 단위
gu_dens_sum['행정구 인구밀도_norm'] = scaler.fit_transform(gu_dens_sum[['인구밀도']])


## 읍면동 단위

# 구별 리스트
gu_list = dens_sort['행정구'].unique()

# 구별 DataFrame 저장 딕셔너리
gu_dfs = {}

for gu in gu_list:
    gu_df = dens_sort[dens_sort['행정구'] == gu].copy()
    
    # 인구밀도 계산 (NaN 방지)
    gu_df['인구밀도'] = (gu_df['인구(명)'] / gu_df['면적(㎢)']).round(2)
    gu_df['인구밀도'] = gu_df['인구밀도'].fillna(0)
    
    # 정규화 (2D array 형태로 변환)
    gu_df[f'{gu} 인구밀도_norm'] = scaler.fit_transform(gu_df[['인구밀도']])
    
    gu_dfs[gu] = gu_df



## 출력

## 행정구 단위
gu_dens_sum

## 읍면동 단위

# Jung_gu =
gu_dfs['중구'].sort_values(['인구밀도'], ascending=False)
# Dong_gu =
gu_dfs['동구'].sort_values(['인구밀도'], ascending=False)
# Seo_gu =
gu_dfs['서구'].sort_values(['인구밀도'], ascending=False)
# Nam_gu =
gu_dfs['남구'].sort_values(['인구밀도'], ascending=False)
# Buk_gu =
gu_dfs['북구'].sort_values(['인구밀도'], ascending=False)
# Suseong_gu =
gu_dfs['수성구'].sort_values(['인구밀도'], ascending=False)
# Dalseo_gu =
gu_dfs['달서구'].sort_values(['인구밀도'], ascending=False)
# Dalseong_gun =
gu_dfs['달성군'].sort_values(['인구밀도'], ascending=False)
# Gunwi_gun =
gu_dfs['군위군'].sort_values(['인구밀도'], ascending=False)

```

```{python}

# () mapping

import pandas as pd
import geopandas as gpd
import folium

# 1. 인구 밀도 데이터 로드 (11.csv)
# cp949 인코딩으로 CSV 파일을 읽어옵니다.
pop_density_df = pd.read_csv('.\data\읍면동 전체 인구밀도.csv')

# 2. 대구 행정동 경계 지도 데이터 로드 (GeoJSON)
geo_daegu = gpd.read_file('.\data\hangjeongdong_대구광역시.geojson')
geo_gyeongbuk = gpd.read_file(".\data\hangjeongdong_경상북도.geojson")

# 경상북도 데이터에서 군위군만 필터링합니다.
geo_gunwi = geo_gyeongbuk[geo_gyeongbuk['adm_nm'].str.contains('경상북도 군위군', na=False)].copy()

# 대구와 군위군 데이터를 합칩니다.
geo_merged = pd.concat([geo_daegu, geo_gunwi], ignore_index=True)

# GeoDataFrame으로 변환하고 좌표계를 설정합니다.
geo_merged = gpd.GeoDataFrame(geo_merged, crs=geo_daegu.crs)

# 불필요한 공백을 제거하고 '경상북도 군위군'을 '군위군'으로 변경합니다.
geo_merged['adm_nm'] = geo_merged['adm_nm'].str.strip()
geo_merged['adm_nm'] = geo_merged['adm_nm'].str.replace('경상북도 군위군', '군위군', regex=False)


# 3. 데이터 병합: 지도 데이터에 인구 밀도 데이터 결합
# ======================== ✨ 핵심 수정 부분 ✨ ========================
# 'adm_nm' 컬럼(예: "대구광역시 중구 동인동")에서 마지막 이름(예: "동인동")만 추출하여 새 컬럼 생성
geo_merged['읍면동_key'] = geo_merged['adm_nm'].apply(lambda x: x.split(' ')[-1])

# 새로 만든 '읍면동_key'를 기준으로 인구 밀도 데이터와 병합합니다.
merged_gdf = geo_merged.merge(pop_density_df, left_on='읍면동_key', right_on='읍면동')
# ======================================================================


# 4. 지도 생성 (대구 중심 좌표)
m = folium.Map(location=[35.8714, 128.6014], zoom_start=11)

# 5. 단계 구분도 (Choropleth) 추가
folium.Choropleth(
    geo_data=merged_gdf,
    name='인구 밀도',
    data=merged_gdf,
    columns=['읍면동', '인구밀도'], # '읍면동'을 key로, '인구밀도'를 값으로 사용
    key_on='feature.properties.읍면동', # geo_data의 feature.properties에서 '읍면동'을 기준으로 연결
    fill_color='YlOrRd',  # 색상 스케일: 노란색에서 빨간색으로
    fill_opacity=0.7,
    line_opacity=0.2,
    legend_name='인구 밀도 (명/㎢)' # 범례 제목
).add_to(m)

# 6. 레이어 컨트롤 추가
folium.LayerControl().add_to(m)

# 7. 툴팁(마우스 오버) 추가: 각 행정동 위에 마우스를 올리면 정보가 표시됨
tooltip = folium.features.GeoJsonTooltip(
    fields=['읍면동', '인구밀도'],
    aliases=['행정동:', '인구밀도:'],
    style=("background-color: white; color: #333333; font-family: arial; font-size: 12px; padding: 10px;")
)

folium.GeoJson(
    merged_gdf,
    style_function=lambda x: {'fillColor': 'none', 'color': 'black', 'weight': 0.5},
    tooltip=tooltip
).add_to(m)


# 8. 지도 파일로 저장
m.save('전체 인구 밀도_map.html')

print("인구 밀도 지도가 daegu_population_density_map.html 파일로 저장되었습니다.")

```

## (2) 위험 취약 연령 인구 밀도: ① 어린이 ② 고령자

```{python}

# (2) 4_2_age ############################################################

# 전처리

# 동·읍·면_연령별_주민등록인구_내국인_전체연령_20250812133656
# https://kosis.daegu.go.kr/statHtml/statHtml.do?orgId=203&tblId=DT_203N100020&lang_mode=ko&vw_cd=MT_OTITLE&list_id=203_B203_05&conn_path=I4

age = pd.read_csv('./data/4_2_age.csv')

age.rename(columns={'행정구역':'행정구',
                    '동읍면': '읍면동'}, 
                    inplace=True)
# age.info()
# age.head()


# 쉼표와 '-' 처리 후 숫자형으로 변환
for col in ['계', '남자', '여자']:
    age[col] = (
        age[col]
        .astype(str)               # 문자열 변환
        .str.replace(',', '', regex=False)  # 쉼표 제거
        .str.strip()               # 앞뒤 공백 제거
        .replace({'': '0', '-': '0'})       # 빈값과 '-'를 0으로
        .astype(int)               # 정수형 변환
    )

# 변환 확인
print(age.info())
print(age.head())




# 연령 필터링
# age['연령'].unique()

# 어린이: 0~14세
child = ['0~4세', '5~9세', '10~14세']
age_child = age[age['연령'].isin(child)]

# 노인: 65세 이상
senior = ['65~69세', '70~74세', '75~79세','80~84세', '85~89세', '90~94세','95~99세', '100세이상']
age_senior = age[age['연령'].isin(senior)]


# 어린이 인구 합계
child_sum = (
    age_child
    .groupby(['행정구', '읍면동'], as_index=False)['계']
    .sum()
    .rename(columns={'계': '어린이수'})
)
# child_sum.info()

# 노인 인구 합계
senior_sum = (
    age_senior
    .groupby(['행정구', '읍면동'], as_index=False)['계']
    .sum()
    .rename(columns={'계': '고령자수'})
)
# senior_sum.info()

```

```{python}

# (1) 구 전체 : ['읍면동'] == '소계'
child_gu = child_sum[child_sum['읍면동'] == '소계'][['행정구','어린이수']]
senior_gu = senior_sum[senior_sum['읍면동'] == '소계'][['행정구','고령자수']]

# dens 데이터와 병합 -> 면적 정보
gu_dens_sum_4_age = gu_dens_sum[['행정구','인구(명)','면적(㎢)','인구밀도']]

age_gu = pd.concat([gu_dens_sum_4_age.set_index(['행정구']),
                    child_gu.set_index(['행정구']),
                    senior_gu.set_index(['행정구'])],
                    axis=1).reset_index()


# 연령별 인구밀도 계산
age_gu['어린이_인구밀도'] = (age_gu['어린이수'] / age_gu['면적(㎢)']).round(2)
age_gu['어린이 인구밀도_norm'] = scaler.fit_transform(age_gu[['어린이_인구밀도']])
age_gu['고령자_인구밀도'] = (age_gu['고령자수'] / age_gu['면적(㎢)']).round(2)
age_gu['고령자 인구밀도_norm'] = scaler.fit_transform(age_gu[['고령자_인구밀도']])
# age_gu
# len(age_gu['행정구'].unique())


## 출력

age_gu
# age_gu.to_csv("어린이 고령자 행정구 인구밀도.csv", index=False, encoding="utf-8-sig")

```

```{python}
# (2) 구 내 동읍면 : ['읍면동'] != '소계'
child_dong = child_sum[child_sum['읍면동'] != '소계']
senior_dong = senior_sum[senior_sum['읍면동'] != '소계']


# dens 데이터와 병합 -> 면적 정보
dong_dens_df = pd.concat(gu_dfs.values(), ignore_index=True)
dong_dens_4_age = dong_dens_df[['행정구','읍면동','인구(명)','면적(㎢)','인구밀도']]
# dong_dens_4_age['읍면동'].unique()

age_dong = pd.concat([dong_dens_4_age.set_index(['행정구','읍면동']),
                    child_dong.set_index(['행정구','읍면동']),
                    senior_dong.set_index(['행정구','읍면동'])],
                    axis=1).reset_index()


# 연령별 인구밀도 계산
age_dong['어린이_인구밀도'] = (age_dong['어린이수'] / age_dong['면적(㎢)']).round(2)
age_dong['어린이 인구밀도_norm'] = scaler.fit_transform(age_dong[['어린이_인구밀도']])
age_dong['고령자_인구밀도'] = (age_dong['고령자수'] / age_dong['면적(㎢)']).round(2)
age_dong['고령자 인구밀도_norm'] = scaler.fit_transform(age_dong[['고령자_인구밀도']])

# age_dong
# len(age_dong['행정구'].unique())
# len(age_dong['읍면동'].unique())


## 출력
# age_dong.to_csv("어린이 고령자 읍면동 인구밀도.csv", index=False, encoding="utf-8-sig")

# Jung_gu = 
age_dong[age_dong['행정구'] == '중구']
# Dong_gu = 
age_dong[age_dong['행정구'] == '동구']
# Seo_gu = 
age_dong[age_dong['행정구'] == '서구']
# Nam_gu = 
age_dong[age_dong['행정구'] == '남구']
# Buk_gu = 
age_dong[age_dong['행정구'] == '북구']
# Suseong_gu = 
age_dong[age_dong['행정구'] == '수성구']
# Dalseo_gu = 
age_dong[age_dong['행정구'] == '달서구']
# Dalseong_gun = 
age_dong[age_dong['행정구'] == '달성군']
# Gunwi_gun = 
age_dong[age_dong['행정구'] == '군위군']

```

```{python}
# (3) sort

## 구
# age_gu.columns
age_gu_child = age_gu[['행정구', '인구(명)', '면적(㎢)', '인구밀도', 
                       '어린이수', '어린이_인구밀도', '어린이 인구밀도_norm']]
age_gu_senior = age_gu[['행정구', '인구(명)', '면적(㎢)', '인구밀도', 
                        '고령자수', '고령자_인구밀도', '고령자 인구밀도_norm']]

## 출력

# 행정구 어린이수 내림차순
age_gu_child.sort_values(['어린이수'], ascending=False)
# 행정구 어린이 인구밀도 내림차순
age_gu_child.sort_values(['어린이_인구밀도'], ascending=False)


# 행정구 고령자수 내림차순
age_gu_senior.sort_values(['고령자수'], ascending=False)
# 행정구 고령자 인구밀도 내림차순
age_gu_senior.sort_values(['고령자_인구밀도'], ascending=False)
```

```{python}
## 동
age_dong_child = age_dong[['행정구', '읍면동', '인구(명)', '면적(㎢)', '인구밀도', 
                           '어린이수', '어린이_인구밀도', '어린이 인구밀도_norm']]
age_dong_senior = age_dong[['행정구', '읍면동', '인구(명)', '면적(㎢)', '인구밀도',
                            '고령자수', '고령자_인구밀도', '고령자 인구밀도_norm']]

## 대구시 전체 동 내 sort 10

age_dong_child.sort_values(['어린이수'], ascending=False).head(10)
age_dong_child.sort_values(['어린이_인구밀도'], ascending=False).head(10)
age_dong_senior.sort_values(['고령자수'], ascending=False).head(10)
age_dong_senior.sort_values(['고령자_인구밀도'], ascending=False).head(10)


## 각 행정구 내 sort
# age_dong.info()
# len(age_dong['행정구'].unique())



## 출력

# 중구: Jung_gu = 
age_dong_child[age_dong_child['행정구'] == '중구'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '중구'].sort_values(['고령자수'], ascending=False)

# 동구: Dong_gu = 
age_dong_child[age_dong_child['행정구'] == '동구'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '동구'].sort_values(['고령자수'], ascending=False)

# 서구: Seo_gu = 
age_dong_child[age_dong_child['행정구'] == '서구'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '서구'].sort_values(['고령자수'], ascending=False)

# 남구: Nam_gu = 
age_dong_child[age_dong_child['행정구'] == '남구'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '남구'].sort_values(['고령자수'], ascending=False)

# 북구: Buk_gu = 
age_dong_child[age_dong_child['행정구'] == '북구'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '북구'].sort_values(['고령자수'], ascending=False)

# 수성구: Suseong_gu = 
age_dong_child[age_dong_child['행정구'] == '수성구'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '수성구'].sort_values(['고령자수'], ascending=False)

# 달서구: Dalseo_gu = 
age_dong_child[age_dong_child['행정구'] == '달서구'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '달서구'].sort_values(['고령자수'], ascending=False)

# 달성군: Dalseong_gun = 
age_dong_child[age_dong_child['행정구'] == '달성군'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '달성군'].sort_values(['고령자수'], ascending=False)

# 군위군: Gunwi_gun = 
age_dong_child[age_dong_child['행정구'] == '군위군'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '군위군'].sort_values(['고령자수'], ascending=False)

```

```{python}
# () mapping
```

## (3) 외국인 인구 밀도

```{python}
# (3) 4_3_foreign ############################################################
# 동·읍·면별_내·외국인_20250812141415
# https://kosis.daegu.go.kr/statHtml/statHtml.do?orgId=203&tblId=DT_203N100015&lang_mode=ko&vw_cd=MT_OTITLE&list_id=203_B203_05&conn_path=I4

# 전처리

fore = pd.read_csv('./data/4_3_foreign.csv')

for col in ['총인구', '한국인', '외국인']:
    fore[col] = (
        fore[col]
        .astype(str)
        .str.replace(',', '')
        .str.strip()
        .replace('-', '0')
        .astype(int)
    )

fore.rename(columns={'행정구역':'행정구',
                    '동읍면': '읍면동',
                    '총인구': '총 인구(명)',
                    '한국인': '한국인 인구(명)', 
                    '외국인': '외국인 인구(명)'}, 
                    inplace=True)

fore = fore[(fore['행정구'] != '합계') & (fore['성별'] == '계')]

fore.info()
fore.head()


# 행정구별 외국인 인구
fore_gu = fore[fore['읍면동'] == '소계'][['행정구', '총 인구(명)', '외국인 인구(명)']]

# 읍면동별 외국인 인구
fore_dong = fore[fore['읍면동'] != '소계'][['행정구', '읍면동', '총 인구(명)', '외국인 인구(명)']]


```

```{python}

# 외국인 인구 밀도

# (1) 행정구별 외국인 인구 밀도
gu_area = dens.groupby('행정구')[['면적(㎢)']].sum().reset_index()

fore_gu = pd.merge(
    fore_gu,
    gu_area,
    on='행정구',
    how='left'
)

fore_gu['외국인 인구밀도'] = (fore_gu['외국인 인구(명)'] / fore_gu['면적(㎢)']).round(2)
# fore_gu

# (2) 읍면동별 외국인 인구 밀도
dong_area = dens.groupby('읍면동')[['면적(㎢)']].sum().reset_index()

fore_dong = pd.merge(
    fore_dong,
    dong_area,
    on='읍면동',
    how='left'
)

fore_dong['외국인 인구밀도'] = (fore_dong['외국인 인구(명)'] / fore_dong['면적(㎢)']).round(2)
# fore_dong


## 출력

# (1) 행정구별 외국인 인구 밀도
# fore_gu

fore_gu.sort_values(by='외국인 인구밀도', ascending=False)


# (2) 읍면동별 외국인 인구 밀도
# fore_dong

# 읍면동별 외국인 인구 밀도 top 10
fore_gu.sort_values(by='외국인 인구밀도', ascending=False).head(10)


```

```{python}

# 외국인 인구밀도 정규화

# (1) 행정구별 외국인 인구 밀도
fore_gu['외국인 인구밀도_norm'] = scaler.fit_transform(
    fore_gu[['외국인 인구밀도']])



# (2) 읍면동별 외국인 인구 밀도
fore_dong['외국인 인구밀도_norm'] = scaler.fit_transform(
    fore_dong[['외국인 인구밀도']])

# 행정구별로 데이터프레임 분리
# Jung_gu      = 
fore_dong[fore_dong['행정구'] == '중구']
# Dong_gu      = 
fore_dong[fore_dong['행정구'] == '동구']
# Seo_gu       = 
fore_dong[fore_dong['행정구'] == '서구']
# Nam_gu       = 
fore_dong[fore_dong['행정구'] == '남구']
# Buk_gu       = 
fore_dong[fore_dong['행정구'] == '북구']
# Suseong_gu   = 
fore_dong[fore_dong['행정구'] == '수성구']
# Dalseo_gu    = 
fore_dong[fore_dong['행정구'] == '달서구']
# Dalseong_gun = 
fore_dong[fore_dong['행정구'] == '달성군']
# Gunwi_gun    = 
fore_dong[fore_dong['행정구'] == '군위군']



# 출력

# fore_gu.to_csv("행정구 외국인 인구.csv", index=False, encoding="utf-8-sig")
# fore_dong.to_csv("읍면동 외국인 인구.csv", index=False, encoding="utf-8-sig")


```

```{python}
# () mapping
```

## () 우선대응 필요: 인구밀도 상위 20% + 고령자수 상위 30%

```{python}
# dens.info()
# age.info()
# fore.info()


# 1) 데이터 전처리
age['계'] = pd.to_numeric(age['계'], errors='coerce')
age['연령'] = age['연령'].astype(str)

fore['총 인구(명)'] = pd.to_numeric(fore['총 인구(명)'], errors='coerce')
fore['외국인 인구(명)'] = pd.to_numeric(fore['외국인 인구(명)'], errors='coerce')

# 2) 고령자(65세 이상) 추출 및 읍면동별 합산
# age_65 = age[age['연령'].str.contains(r'^(65|70|75|80|85|90|95|100)', regex=True)]
age_65 = age[age['연령'].str.contains(r'^65|^70|^75|^80|^85|^90|^95|^100')]

age_65_sum = (
    age_65.groupby(['행정구', '읍면동'])['계']
    .sum()
    .reset_index()
    .rename(columns={'계': '고령자수'})
)

# 3) 외국인 비율 계산 (읍면동별)
fore_sum = (
    fore.groupby(['행정구', '읍면동'], as_index=False)[['총 인구(명)', '외국인 인구(명)']].sum()
)
fore_sum['외국인비율'] = fore_sum['외국인 인구(명)'] / fore_sum['총 인구(명)']

# 4) dens와 병합 (읍면동 단위)
# 필요시 '소계' 등 합계 행 제거
dens_clean = dens[~dens['읍면동'].str.contains('소계|합계')]

df_merge = dens_clean.merge(age_65_sum, on=['행정구', '읍면동'], how='left')
df_merge = df_merge.merge(fore_sum[['행정구', '읍면동', '외국인비율']], on=['행정구', '읍면동'], how='left')

# 5) 결측치 처리
df_merge['고령자수'] = df_merge['고령자수'].fillna(0).astype(int)
df_merge['외국인비율'] = df_merge['외국인비율'].fillna(0)

# 6) 우선 대응 지역 조건
pop_density_thresh = df_merge['인구밀도'].quantile(0.8)
elderly_thresh = df_merge['고령자수'].quantile(0.7)
# foreign_thresh = 0.5

priority_areas = df_merge[
    (df_merge['인구밀도'] >= pop_density_thresh) &
    (df_merge['고령자수'] >= elderly_thresh) ]
    # (df_merge['외국인비율'] >= foreign_thresh)

# 7) 결과 출력
print("우선 대응 필요 읍면동:")
print(priority_areas[['행정구', '읍면동', '인구밀도', '고령자수']])


```

## () 고위험 top 10: 인구밀도40% + 고령자40% + 외국인20%

```{python}

# 결측치 처리
df_merge['고령자수'] = df_merge['고령자수'].fillna(0)
df_merge['외국인비율'] = df_merge['외국인비율'].fillna(0)

df_merge.columns

# 사용할 컬럼 추출
risk_df = df_merge[['행정구', '읍면동', '인구밀도', '고령자수', '외국인비율']].copy()

# inf 값 → NaN 변환
risk_df[['인구밀도', '고령자수', '외국인비율']] = risk_df[['인구밀도', '고령자수', '외국인비율']].replace([np.inf, -np.inf], np.nan)

# NaN 채우기 (예: 0으로 채움, 또는 평균/중앙값으로)
risk_df = risk_df.fillna(0)


# 정규화 (Min-Max scaling)
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()
risk_df[['인구밀도_norm', '고령자수_norm', '외국인비율_norm']] = scaler.fit_transform(
    risk_df[['인구밀도', '고령자수', '외국인비율']])


# 가중치 지정
weights = {
    '인구밀도_norm': 0.4,
    '고령자수_norm': 0.4,
    '외국인비율_norm': 0.2
}

# 위험도 점수 계산
risk_df['위험도점수'] = (
    risk_df['인구밀도_norm'] * weights['인구밀도_norm'] +
    risk_df['고령자수_norm'] * weights['고령자수_norm'] +
    risk_df['외국인비율_norm'] * weights['외국인비율_norm']
)

# 위험도 점수 상위 10개 지역 출력
top_risk_areas = risk_df.sort_values(by='위험도점수', ascending=False).head(10)

print(top_risk_areas[['행정구', '읍면동', '위험도점수']])

```

# 3. 지리적 요인

```{python}
# 지도 전처리

import geopandas as gpd
import pandas as pd
import folium

#########################################################################
# 1. 행정동 GeoJSON 불러오기
# -----------------------------------------------------------------------
geo = gpd.read_file(".\hangjeongdong_대구광역시.geojson")
geo2 = gpd.read_file(".\hangjeongdong_경상북도.geojson")

# 군위 데이터 추출
geo1 = geo2[geo2['adm_nm'].str.contains('경상북도 군위', na=False)].copy()

# 대구 + 군위 합치기
geo_merged = pd.concat([geo, geo1], ignore_index=True)
geo_merged = gpd.GeoDataFrame(geo_merged, crs=geo.crs)

#########################################################################
# 2. 인구밀도 CSV 불러오기
# -----------------------------------------------------------------------
pop = dens
# '행정구'와 '읍면동'을 합쳐 'adm_nm' 임시 생성
pop['adm_nm'] = pop['행정구'] + " " + pop['읍면동']

#########################################################################
# ✨ [수정 1] 데이터 병합 전, KEY 값(adm_nm) 통일
# -----------------------------------------------------------------------
# 1. 양쪽 데이터의 불필요한 앞뒤 공백 제거
geo_merged['adm_nm'] = geo_merged['adm_nm'].str.strip()
pop['adm_nm'] = pop['adm_nm'].str.strip()

# 2. GeoJSON의 '경상북도 군위군'을 '군위군'으로 변경 (대구 편입 반영)
geo_merged['adm_nm'] = geo_merged['adm_nm'].str.replace('경상북도 군위군', '군위군', regex=False)

# 3. 인구 데이터의 'adm_nm'을 GeoJSON 형식('대구광역시 OO구 OO동')과 일치시키기
# 군위군은 '대구광역시'를 붙이지 않도록 예외 처리
is_gunwi = pop['행정구'] == '군위군'
pop.loc[~is_gunwi, 'adm_nm'] = '대구광역시 ' + pop.loc[~is_gunwi, 'adm_nm']



```

## (1) 배수펌프장 위치

```{python}

# 배수펌프장 데이터

#########################################################################
# 3. 재해위험지구 / 배수펌프장 데이터
# -----------------------------------------------------------------------
hazard = pd.read_csv("재해위험지역/대구광역시_재해위험지구_통합.csv", encoding="cp949")
pump = pd.read_csv("배수펌프장/대구광역시 달성군_배수펌프장_20240829.csv", encoding="cp949")
pump1 = pd.read_csv("배수펌프장/대구광역시 중구 배수펌프장정보_20201013.csv", encoding="cp949")
pump2 = pd.read_csv("배수펌프장/대구광역시_서구_배수펌프장 현황_20250716.csv", encoding="cp949")

# 펌프장 데이터 전처리 함수
def preprocess_pump(df, addr_col, name_col):
    df = df.dropna(subset=[addr_col, name_col, "위도", "경도"])
    df_renamed = df.rename(columns={name_col: "펌프장명", addr_col: "주소"})
    return df_renamed[["주소", "펌프장명", "위도", "경도"]]

pump = preprocess_pump(pump, "소재지지번주소", "배수펌프장명")
pump1 = preprocess_pump(pump1, "펌프장지번주소", "펌프장명")
pump2 = pump2.rename(columns={"소재지 지번 주소": "주소"}) # pump2 컬럼 이름 통일
pump2 = pump2.dropna(subset=["주소", "펌프장명", "위도", "경도"])

# 펌프장 데이터 합치기 + 중복 제거
pump_all = pd.concat([pump, pump1, pump2], ignore_index=True).drop_duplicates()

# GeoDataFrame으로 변환
hazard_gdf = gpd.GeoDataFrame(hazard, geometry=gpd.points_from_xy(hazard['경도'], hazard['위도']), crs="EPSG:4326")
pump_gdf = gpd.GeoDataFrame(pump_all, geometry=gpd.points_from_xy(pump_all['경도'], pump_all['위도']), crs="EPSG:4326")

#########################################################################
# 4. 행정동별 시설 개수 집계
# -----------------------------------------------------------------------
hazard_join = gpd.sjoin(hazard_gdf, geo_merged, how="left", predicate="within")
pump_join = gpd.sjoin(pump_gdf, geo_merged, how="left", predicate="within")

hazard_count = hazard_join.groupby("adm_nm").size().reset_index(name="risk_count")
pump_count = pump_join.groupby("adm_nm").size().reset_index(name="pump_count")


```

## (2)저고도(저지대) 위치 분석

```{python}
# 저지대 기준 적용 -> 저지대 도출


```

# \[결론\]

```{python}
# 동일가중치 -> 종합점수 -> 시각화
# 가중치는 탭 하나 해서 조절 가능하게

```

```{python}
# 위험점수 높은지역/낮은지역 구분 -> 지역별로 비교분석
# 위험도 점수 히스토그램 -> 낮은지역, 높은지역 뽑아서 비교
# 비교: 각 인자별로 어떤 특성때문에 점수가 낮/높게 나오는지



# + 대구시 지리, 인구, 날씨 외 다른 요인이 있을 수 있으니까, 침수 위험이 높은 지역 기준으로
# 기사 등등등 기타 중요 요인 찾아보기 -> 해결책 제시/도출(해결책은 구체적이지 않아도 ~~~ 방안이 있을 것이다 제시)
```

## 과거 재난 지역 대비

-\> (결론단계에서 사용 예정)

데이터 분석을 통한 위험지역 도출 후 실제 위험지역과 대비를 통한 검증 데이터로 활용 예정

```{python}
pd.read_csv('./data/대구광역시_재해위험지구_통합.csv', encoding='cp949')


# 실제 침수 데이터랑 매칭이 되는지 점검 -> 동으로 분석 진행(예정)
```

# 

## () 대구시 내 인구 밀도에 따른 위험도 분석 - 읍면동 단위

```{python}
# 인구지도


```

```{python}
# 인구 + 배수펌프

#########################################################################
# 5. 모든 데이터 통합
# -----------------------------------------------------------------------
df = geo_merged.merge(pop[['adm_nm','인구밀도']], on="adm_nm", how="left")
df = df.merge(hazard_count, on="adm_nm", how="left")
df = df.merge(pump_count, on="adm_nm", how="left")

# 병합 후 발생할 수 있는 NaN(누락값)을 0으로 채우기
df[['인구밀도', 'risk_count', 'pump_count']] = df[['인구밀도', 'risk_count', 'pump_count']].fillna(0)

#########################################################################
# ✨ [수정 2] 안전한 정규화 (0으로 나누기 방지)
# -----------------------------------------------------------------------
for col in ['인구밀도', 'risk_count', 'pump_count']:
    min_val = df[col].min()
    max_val = df[col].max()
    
    # 최댓값과 최솟값이 같으면(모든 값이 동일하면) 분모가 0이 되므로 예외 처리
    if (max_val - min_val) > 0:
        df[col + '_norm'] = (df[col] - min_val) / (max_val - min_val)
    else:
        # 모든 값이 같을 경우 정규화 값은 0으로 설정
        df[col + '_norm'] = 0

#########################################################################
# 7. 위험 스코어 계산
# -----------------------------------------------------------------------
df['risk_score'] = 0.4 * df['인구밀도_norm'] + 0.5 * df['risk_count_norm'] - 0.1 * df['pump_count_norm']

#########################################################################
# 8. 지도 시각화
# -----------------------------------------------------------------------
m = folium.Map(location=[35.87, 128.6], zoom_start=10)

folium.Choropleth(
    geo_data=df,  # GeoDataFrame을 직접 전달하는 것을 권장
    data=df,
    columns=["adm_nm", "risk_score"],
    key_on="feature.properties.adm_nm",
    fill_color="YlOrRd",
    fill_opacity=0.7,
    line_opacity=0.5,
    legend_name="침수 위험 스코어"
).add_to(m)

# 지도 저장
m.save("대구_침수위험스코어_완성.html")

print("지도 생성이 완료되었습니다: 대구_침수위험스코어_완성.html")
```

## () 대구시 내 어린이 인구 밀도에 따른 위험도 분석 - 읍면동 단위

```{python}
# 인구지도
```

```{python}
# 인구 + 배수펌프
```

## () 대구시 내 고령자 인구 밀도에 따른 위험도 분석 - 읍면동 단위

```{python}
# 인구지도
```

```{python}
# 인구 + 배수펌프
```

## () 대구시 내 외국인 인구 밀도에 따른 위험도 분석 - 읍면동 단위

```{python}
# 인구지도
```

```{python}
# 인구 + 배수펌프
```