---
title: "Safe Daegu Flood"
author: "team 7"
format: dashboard
---

```{python}

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

from scipy.stats import uniform
from scipy.stats import norm
from scipy.stats import binom
import scipy.stats as sp
from scipy.stats import t
import scipy.stats as stats
from scipy import stats

import math
from collections import Counter
from scipy.integrate import quad
from scipy.stats import uniform, norm, binom, poisson, expon, gamma, t, chi2, f, beta
from scipy.stats import bernoulli
from scipy.stats import ttest_rel

plt.rcParams['font.family'] = 'Malgun Gothic'
plt.rcParams['axes.unicode_minus'] = False

import plotly.express as px
import plotly.graph_objects as go
import geopandas as gpd
import json 

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()

# csv로 저장하기
# .to_csv("파일이름.csv", index=False, encoding="utf-8-sig")

```

# 날씨요인

## 대구시 장마 기간 및 기간 내 총 강수량 분석

```{python}

rain = pd.read_csv('./data/rain.csv')
rain.info()
rain

```

# 과거 재난 지역 분석

-\> (결론단계에서 사용 예정)

데이터 분석을 통한 위험지역 도출 후 실제 위험지역과 대비를 통한 검증 데이터로 활용 예정

```{python}

pd.read_csv('./data/대구광역시_재해위험지구_통합.csv', encoding='cp949')


```

# 인구요인

## (1) 전체 인구 밀도: ① 행정구 ② 읍면동

```{python}
# (1) 4_1_dens ############################################################

# 전처리

# 행정구역별 인구밀도
# https://www.daegu.go.kr/index.do?menu_id=00000253

dens = pd.read_csv('./data/4_1_dens.csv')
dens.info()
dens.head()

dens = dens[dens['읍면동'] != '소계']
# len(dens['행정구'].unique())
```

```{python}

# (1) 읍면동 단위 인구밀도
dens['인구밀도'] = (dens['인구(명)'] / dens['면적(㎢)']).round(2)



# (2) 행정구 단위: 각 행정구의 (총 인구 / 총 면적) 기준 인구밀도
gu_dens = dens[['행정구','인구(명)','면적(㎢)']].groupby(['행정구'])

gu_dens_sum = gu_dens.sum().reset_index().rename(columns={'index': '행정구'})
gu_dens_sum['인구밀도'] = (gu_dens_sum['인구(명)'] / gu_dens_sum['면적(㎢)']).round(2)



## 출력

# 행정구 단위 인구밀도
gu_dens_sum
# gu_dens_sum.to_csv("행정구 전체 인구밀도.csv", index=False, encoding="utf-8-sig")

# 읍면동 단위 인구밀도
dens
# dens.to_csv("읍면동 전체 인구밀도.csv", index=False, encoding="utf-8-sig")

```

```{python}

# (3) sort -> 그래프 시각화

## 대구 전체 읍면동 인구밀도
scaler = MinMaxScaler()
dens['읍면동 인구밀도_norm'] = scaler.fit_transform(dens[['인구밀도']])
# 읍면동 인구밀도 상위 10
dens_sort = dens[['행정구','읍면동','인구(명)','면적(㎢)','인구밀도','읍면동 인구밀도_norm']]
dens_sort.sort_values(['인구밀도'], ascending=False).head(10)
# 읍면동 인구밀도 하위 10
# dens_sort.sort_values(['인구밀도'], ascending=True).head(10)


## 행정구 인구밀도 내림차순
gu_dens_sum.sort_values(['인구밀도'], ascending=False)



## 출력

## 행정구 인구밀도 내림차순
gu_dens_sum.sort_values(['인구밀도'], ascending=False)

# 읍면동 인구밀도 상위 10
dens_sort.sort_values(['인구밀도'], ascending=False).head(10)

```

```{python}

# (4) norm 활용 -> 지도 히트맵?

## 행정구 단위
gu_dens_sum['행정구 인구밀도_norm'] = scaler.fit_transform(gu_dens_sum[['인구밀도']])


## 읍면동 단위

# 구별 리스트
gu_list = dens_sort['행정구'].unique()

# 구별 DataFrame 저장 딕셔너리
gu_dfs = {}

for gu in gu_list:
    gu_df = dens_sort[dens_sort['행정구'] == gu].copy()
    
    # 인구밀도 계산 (NaN 방지)
    gu_df['인구밀도'] = (gu_df['인구(명)'] / gu_df['면적(㎢)']).round(2)
    gu_df['인구밀도'] = gu_df['인구밀도'].fillna(0)
    
    # 정규화 (2D array 형태로 변환)
    gu_df[f'{gu} 인구밀도_norm'] = scaler.fit_transform(gu_df[['인구밀도']])
    
    gu_dfs[gu] = gu_df



## 출력

## 행정구 단위
gu_dens_sum

## 읍면동 단위

# Jung_gu =
gu_dfs['중구'].sort_values(['인구밀도'], ascending=False)
# Dong_gu =
gu_dfs['동구'].sort_values(['인구밀도'], ascending=False)
# Seo_gu =
gu_dfs['서구'].sort_values(['인구밀도'], ascending=False)
# Nam_gu =
gu_dfs['남구'].sort_values(['인구밀도'], ascending=False)
# Buk_gu =
gu_dfs['북구'].sort_values(['인구밀도'], ascending=False)
# Suseong_gu =
gu_dfs['수성구'].sort_values(['인구밀도'], ascending=False)
# Dalseo_gu =
gu_dfs['달서구'].sort_values(['인구밀도'], ascending=False)
# Dalseong_gun =
gu_dfs['달성군'].sort_values(['인구밀도'], ascending=False)
# Gunwi_gun =
gu_dfs['군위군'].sort_values(['인구밀도'], ascending=False)

```

```{python}

# () mapping

```

## (2) 위험 취약 연령 인구 밀도: ① 어린이 ② 고령자

```{python}

# (2) 4_2_age ############################################################

# 전처리

# 동·읍·면_연령별_주민등록인구_내국인_전체연령_20250812133656
# https://kosis.daegu.go.kr/statHtml/statHtml.do?orgId=203&tblId=DT_203N100020&lang_mode=ko&vw_cd=MT_OTITLE&list_id=203_B203_05&conn_path=I4

age = pd.read_csv('./data/4_2_age.csv')

age.rename(columns={'행정구역':'행정구',
                    '동읍면': '읍면동'}, 
                    inplace=True)
# age.info()
# age.head()


# 쉼표와 '-' 처리 후 숫자형으로 변환
for col in ['계', '남자', '여자']:
    age[col] = (
        age[col]
        .astype(str)               # 문자열 변환
        .str.replace(',', '', regex=False)  # 쉼표 제거
        .str.strip()               # 앞뒤 공백 제거
        .replace({'': '0', '-': '0'})       # 빈값과 '-'를 0으로
        .astype(int)               # 정수형 변환
    )

# 변환 확인
print(age.info())
print(age.head())




# 연령 필터링
# age['연령'].unique()

# 어린이: 0~14세
child = ['0~4세', '5~9세', '10~14세']
age_child = age[age['연령'].isin(child)]

# 노인: 65세 이상
senior = ['65~69세', '70~74세', '75~79세','80~84세', '85~89세', '90~94세','95~99세', '100세이상']
age_senior = age[age['연령'].isin(senior)]


# 어린이 인구 합계
child_sum = (
    age_child
    .groupby(['행정구', '읍면동'], as_index=False)['계']
    .sum()
    .rename(columns={'계': '어린이수'})
)
# child_sum.info()

# 노인 인구 합계
senior_sum = (
    age_senior
    .groupby(['행정구', '읍면동'], as_index=False)['계']
    .sum()
    .rename(columns={'계': '고령자수'})
)
# senior_sum.info()

```

```{python}

# (1) 구 전체 : ['읍면동'] == '소계'
child_gu = child_sum[child_sum['읍면동'] == '소계'][['행정구','어린이수']]
senior_gu = senior_sum[senior_sum['읍면동'] == '소계'][['행정구','고령자수']]

# dens 데이터와 병합 -> 면적 정보
gu_dens_sum_4_age = gu_dens_sum[['행정구','인구(명)','면적(㎢)','인구밀도']]

age_gu = pd.concat([gu_dens_sum_4_age.set_index(['행정구']),
                    child_gu.set_index(['행정구']),
                    senior_gu.set_index(['행정구'])],
                    axis=1).reset_index()


# 연령별 인구밀도 계산
age_gu['어린이_인구밀도'] = (age_gu['어린이수'] / age_gu['면적(㎢)']).round(2)
age_gu['어린이 인구밀도_norm'] = scaler.fit_transform(age_gu[['어린이_인구밀도']])
age_gu['고령자_인구밀도'] = (age_gu['고령자수'] / age_gu['면적(㎢)']).round(2)
age_gu['고령자 인구밀도_norm'] = scaler.fit_transform(age_gu[['고령자_인구밀도']])
# age_gu
# len(age_gu['행정구'].unique())


## 출력

age_gu
# age_gu.to_csv("어린이 고령자 행정구 인구밀도.csv", index=False, encoding="utf-8-sig")

```

```{python}
# (2) 구 내 동읍면 : ['읍면동'] != '소계'
child_dong = child_sum[child_sum['읍면동'] != '소계']
senior_dong = senior_sum[senior_sum['읍면동'] != '소계']


# dens 데이터와 병합 -> 면적 정보
dong_dens_df = pd.concat(gu_dfs.values(), ignore_index=True)
dong_dens_4_age = dong_dens_df[['행정구','읍면동','인구(명)','면적(㎢)','인구밀도']]
# dong_dens_4_age['읍면동'].unique()

age_dong = pd.concat([dong_dens_4_age.set_index(['행정구','읍면동']),
                    child_dong.set_index(['행정구','읍면동']),
                    senior_dong.set_index(['행정구','읍면동'])],
                    axis=1).reset_index()


# 연령별 인구밀도 계산
age_dong['어린이_인구밀도'] = (age_dong['어린이수'] / age_dong['면적(㎢)']).round(2)
age_dong['어린이 인구밀도_norm'] = scaler.fit_transform(age_dong[['어린이_인구밀도']])
age_dong['고령자_인구밀도'] = (age_dong['고령자수'] / age_dong['면적(㎢)']).round(2)
age_dong['고령자 인구밀도_norm'] = scaler.fit_transform(age_dong[['고령자_인구밀도']])

# age_dong
# len(age_dong['행정구'].unique())
# len(age_dong['읍면동'].unique())


## 출력
# age_dong.to_csv("어린이 고령자 읍면동 인구밀도.csv", index=False, encoding="utf-8-sig")

# Jung_gu = 
age_dong[age_dong['행정구'] == '중구']
# Dong_gu = 
age_dong[age_dong['행정구'] == '동구']
# Seo_gu = 
age_dong[age_dong['행정구'] == '서구']
# Nam_gu = 
age_dong[age_dong['행정구'] == '남구']
# Buk_gu = 
age_dong[age_dong['행정구'] == '북구']
# Suseong_gu = 
age_dong[age_dong['행정구'] == '수성구']
# Dalseo_gu = 
age_dong[age_dong['행정구'] == '달서구']
# Dalseong_gun = 
age_dong[age_dong['행정구'] == '달성군']
# Gunwi_gun = 
age_dong[age_dong['행정구'] == '군위군']

```

```{python}
# (3) sort

## 구
# age_gu.columns
age_gu_child = age_gu[['행정구', '인구(명)', '면적(㎢)', '인구밀도', 
                       '어린이수', '어린이_인구밀도', '어린이 인구밀도_norm']]
age_gu_senior = age_gu[['행정구', '인구(명)', '면적(㎢)', '인구밀도', 
                        '고령자수', '고령자_인구밀도', '고령자 인구밀도_norm']]

## 출력

# 행정구 어린이수 내림차순
age_gu_child.sort_values(['어린이수'], ascending=False)
# 행정구 어린이 인구밀도 내림차순
age_gu_child.sort_values(['어린이_인구밀도'], ascending=False)


# 행정구 고령자수 내림차순
age_gu_senior.sort_values(['고령자수'], ascending=False)
# 행정구 고령자 인구밀도 내림차순
age_gu_senior.sort_values(['고령자_인구밀도'], ascending=False)
```

```{python}
## 동
age_dong_child = age_dong[['행정구', '읍면동', '인구(명)', '면적(㎢)', '인구밀도', 
                           '어린이수', '어린이_인구밀도', '어린이 인구밀도_norm']]
age_dong_senior = age_dong[['행정구', '읍면동', '인구(명)', '면적(㎢)', '인구밀도',
                            '고령자수', '고령자_인구밀도', '고령자 인구밀도_norm']]

## 대구시 전체 동 내 sort 10

age_dong_child.sort_values(['어린이수'], ascending=False).head(10)
age_dong_child.sort_values(['어린이_인구밀도'], ascending=False).head(10)
age_dong_senior.sort_values(['고령자수'], ascending=False).head(10)
age_dong_senior.sort_values(['고령자_인구밀도'], ascending=False).head(10)


## 각 행정구 내 sort
# age_dong.info()
# len(age_dong['행정구'].unique())



## 출력

# 중구: Jung_gu = 
age_dong_child[age_dong_child['행정구'] == '중구'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '중구'].sort_values(['고령자수'], ascending=False)

# 동구: Dong_gu = 
age_dong_child[age_dong_child['행정구'] == '동구'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '동구'].sort_values(['고령자수'], ascending=False)

# 서구: Seo_gu = 
age_dong_child[age_dong_child['행정구'] == '서구'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '서구'].sort_values(['고령자수'], ascending=False)

# 남구: Nam_gu = 
age_dong_child[age_dong_child['행정구'] == '남구'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '남구'].sort_values(['고령자수'], ascending=False)

# 북구: Buk_gu = 
age_dong_child[age_dong_child['행정구'] == '북구'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '북구'].sort_values(['고령자수'], ascending=False)

# 수성구: Suseong_gu = 
age_dong_child[age_dong_child['행정구'] == '수성구'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '수성구'].sort_values(['고령자수'], ascending=False)

# 달서구: Dalseo_gu = 
age_dong_child[age_dong_child['행정구'] == '달서구'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '달서구'].sort_values(['고령자수'], ascending=False)

# 달성군: Dalseong_gun = 
age_dong_child[age_dong_child['행정구'] == '달성군'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '달성군'].sort_values(['고령자수'], ascending=False)

# 군위군: Gunwi_gun = 
age_dong_child[age_dong_child['행정구'] == '군위군'].sort_values(['어린이수'], ascending=False)
age_dong_senior[age_dong_senior['행정구'] == '군위군'].sort_values(['고령자수'], ascending=False)

```

```{python}
# () mapping
```

## (3) 외국인 인구 밀도

```{python}
# (3) 4_3_foreign ############################################################
# 동·읍·면별_내·외국인_20250812141415
# https://kosis.daegu.go.kr/statHtml/statHtml.do?orgId=203&tblId=DT_203N100015&lang_mode=ko&vw_cd=MT_OTITLE&list_id=203_B203_05&conn_path=I4

# 전처리

fore = pd.read_csv('./data/4_3_foreign.csv')

for col in ['총인구', '한국인', '외국인']:
    fore[col] = (
        fore[col]
        .astype(str)
        .str.replace(',', '')
        .str.strip()
        .replace('-', '0')
        .astype(int)
    )

fore.rename(columns={'행정구역':'행정구',
                    '동읍면': '읍면동',
                    '총인구': '총 인구(명)',
                    '한국인': '한국인 인구(명)', 
                    '외국인': '외국인 인구(명)'}, 
                    inplace=True)

fore = fore[(fore['행정구'] != '합계') & (fore['성별'] == '계')]

fore.info()
fore.head()


# 행정구별 외국인 인구
fore_gu = fore[fore['읍면동'] == '소계'][['행정구', '총 인구(명)', '외국인 인구(명)']]

# 읍면동별 외국인 인구
fore_dong = fore[fore['읍면동'] != '소계'][['행정구', '읍면동', '총 인구(명)', '외국인 인구(명)']]


```

```{python}

# 외국인 인구 밀도

# (1) 행정구별 외국인 인구 밀도
gu_area = dens.groupby('행정구')[['면적(㎢)']].sum().reset_index()

fore_gu = pd.merge(
    fore_gu,
    gu_area,
    on='행정구',
    how='left'
)

fore_gu['외국인 인구밀도'] = (fore_gu['외국인 인구(명)'] / fore_gu['면적(㎢)']).round(2)
# fore_gu

# (2) 읍면동별 외국인 인구 밀도
dong_area = dens.groupby('읍면동')[['면적(㎢)']].sum().reset_index()

fore_dong = pd.merge(
    fore_dong,
    dong_area,
    on='읍면동',
    how='left'
)

fore_dong['외국인 인구밀도'] = (fore_dong['외국인 인구(명)'] / fore_dong['면적(㎢)']).round(2)
# fore_dong


## 출력

# (1) 행정구별 외국인 인구 밀도
# fore_gu

fore_gu.sort_values(by='외국인 인구밀도', ascending=False)


# (2) 읍면동별 외국인 인구 밀도
# fore_dong

# 읍면동별 외국인 인구 밀도 top 10
fore_gu.sort_values(by='외국인 인구밀도', ascending=False).head(10)


```

```{python}

# 외국인 인구밀도 정규화

# (1) 행정구별 외국인 인구 밀도
fore_gu['외국인 인구밀도_norm'] = scaler.fit_transform(
    fore_gu[['외국인 인구밀도']])



# (2) 읍면동별 외국인 인구 밀도
fore_dong['외국인 인구밀도_norm'] = scaler.fit_transform(
    fore_dong[['외국인 인구밀도']])

# 행정구별로 데이터프레임 분리
# Jung_gu      = 
fore_dong[fore_dong['행정구'] == '중구']
# Dong_gu      = 
fore_dong[fore_dong['행정구'] == '동구']
# Seo_gu       = 
fore_dong[fore_dong['행정구'] == '서구']
# Nam_gu       = 
fore_dong[fore_dong['행정구'] == '남구']
# Buk_gu       = 
fore_dong[fore_dong['행정구'] == '북구']
# Suseong_gu   = 
fore_dong[fore_dong['행정구'] == '수성구']
# Dalseo_gu    = 
fore_dong[fore_dong['행정구'] == '달서구']
# Dalseong_gun = 
fore_dong[fore_dong['행정구'] == '달성군']
# Gunwi_gun    = 
fore_dong[fore_dong['행정구'] == '군위군']



# 출력

# fore_gu.to_csv("행정구 외국인 인구.csv", index=False, encoding="utf-8-sig")
# fore_dong.to_csv("읍면동 외국인 인구.csv", index=False, encoding="utf-8-sig")


```

```{python}
# () mapping
```

## () 우선대응 필요: 인구밀도 상위 20% + 고령자수 상위 30% 

```{python}
# dens.info()
# age.info()
# fore.info()


# 1) 데이터 전처리
age['계'] = pd.to_numeric(age['계'], errors='coerce')
age['연령'] = age['연령'].astype(str)

fore['총 인구(명)'] = pd.to_numeric(fore['총 인구(명)'], errors='coerce')
fore['외국인 인구(명)'] = pd.to_numeric(fore['외국인 인구(명)'], errors='coerce')

# 2) 고령자(65세 이상) 추출 및 읍면동별 합산
# age_65 = age[age['연령'].str.contains(r'^(65|70|75|80|85|90|95|100)', regex=True)]
age_65 = age[age['연령'].str.contains(r'^65|^70|^75|^80|^85|^90|^95|^100')]

age_65_sum = (
    age_65.groupby(['행정구', '읍면동'])['계']
    .sum()
    .reset_index()
    .rename(columns={'계': '고령자수'})
)

# 3) 외국인 비율 계산 (읍면동별)
fore_sum = (
    fore.groupby(['행정구', '읍면동'], as_index=False)[['총 인구(명)', '외국인 인구(명)']].sum()
)
fore_sum['외국인비율'] = fore_sum['외국인 인구(명)'] / fore_sum['총 인구(명)']

# 4) dens와 병합 (읍면동 단위)
# 필요시 '소계' 등 합계 행 제거
dens_clean = dens[~dens['읍면동'].str.contains('소계|합계')]

df_merge = dens_clean.merge(age_65_sum, on=['행정구', '읍면동'], how='left')
df_merge = df_merge.merge(fore_sum[['행정구', '읍면동', '외국인비율']], on=['행정구', '읍면동'], how='left')

# 5) 결측치 처리
df_merge['고령자수'] = df_merge['고령자수'].fillna(0).astype(int)
df_merge['외국인비율'] = df_merge['외국인비율'].fillna(0)

# 6) 우선 대응 지역 조건
pop_density_thresh = df_merge['인구밀도'].quantile(0.8)
elderly_thresh = df_merge['고령자수'].quantile(0.7)
# foreign_thresh = 0.5

priority_areas = df_merge[
    (df_merge['인구밀도'] >= pop_density_thresh) &
    (df_merge['고령자수'] >= elderly_thresh) ]
    # (df_merge['외국인비율'] >= foreign_thresh)

# 7) 결과 출력
print("우선 대응 필요 읍면동:")
print(priority_areas[['행정구', '읍면동', '인구밀도', '고령자수']])


```

## () 고위험 top 10: 인구밀도40% + 고령자40% + 외국인20%

```{python}

# 결측치 처리
df_merge['고령자수'] = df_merge['고령자수'].fillna(0)
df_merge['외국인비율'] = df_merge['외국인비율'].fillna(0)

df_merge.columns

# 사용할 컬럼 추출
risk_df = df_merge[['행정구', '읍면동', '인구밀도', '고령자수', '외국인비율']].copy()

# inf 값 → NaN 변환
risk_df[['인구밀도', '고령자수', '외국인비율']] = risk_df[['인구밀도', '고령자수', '외국인비율']].replace([np.inf, -np.inf], np.nan)

# NaN 채우기 (예: 0으로 채움, 또는 평균/중앙값으로)
risk_df = risk_df.fillna(0)


# 정규화 (Min-Max scaling)
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()
risk_df[['인구밀도_norm', '고령자수_norm', '외국인비율_norm']] = scaler.fit_transform(
    risk_df[['인구밀도', '고령자수', '외국인비율']])


# 가중치 지정
weights = {
    '인구밀도_norm': 0.4,
    '고령자수_norm': 0.4,
    '외국인비율_norm': 0.2
}

# 위험도 점수 계산
risk_df['위험도점수'] = (
    risk_df['인구밀도_norm'] * weights['인구밀도_norm'] +
    risk_df['고령자수_norm'] * weights['고령자수_norm'] +
    risk_df['외국인비율_norm'] * weights['외국인비율_norm']
)

# 위험도 점수 상위 10개 지역 출력
top_risk_areas = risk_df.sort_values(by='위험도점수', ascending=False).head(10)

print(top_risk_areas[['행정구', '읍면동', '위험도점수']])

```

# 지리적 요인

```{python}
# 지도 전처리

import geopandas as gpd
import pandas as pd
import folium

#########################################################################
# 1. 행정동 GeoJSON 불러오기
# -----------------------------------------------------------------------
geo = gpd.read_file(".\hangjeongdong_대구광역시.geojson")
geo2 = gpd.read_file(".\hangjeongdong_경상북도.geojson")

# 군위 데이터 추출
geo1 = geo2[geo2['adm_nm'].str.contains('경상북도 군위', na=False)].copy()

# 대구 + 군위 합치기
geo_merged = pd.concat([geo, geo1], ignore_index=True)
geo_merged = gpd.GeoDataFrame(geo_merged, crs=geo.crs)

#########################################################################
# 2. 인구밀도 CSV 불러오기
# -----------------------------------------------------------------------
pop = dens
# '행정구'와 '읍면동'을 합쳐 'adm_nm' 임시 생성
pop['adm_nm'] = pop['행정구'] + " " + pop['읍면동']

#########################################################################
# ✨ [수정 1] 데이터 병합 전, KEY 값(adm_nm) 통일
# -----------------------------------------------------------------------
# 1. 양쪽 데이터의 불필요한 앞뒤 공백 제거
geo_merged['adm_nm'] = geo_merged['adm_nm'].str.strip()
pop['adm_nm'] = pop['adm_nm'].str.strip()

# 2. GeoJSON의 '경상북도 군위군'을 '군위군'으로 변경 (대구 편입 반영)
geo_merged['adm_nm'] = geo_merged['adm_nm'].str.replace('경상북도 군위군', '군위군', regex=False)

# 3. 인구 데이터의 'adm_nm'을 GeoJSON 형식('대구광역시 OO구 OO동')과 일치시키기
# 군위군은 '대구광역시'를 붙이지 않도록 예외 처리
is_gunwi = pop['행정구'] == '군위군'
pop.loc[~is_gunwi, 'adm_nm'] = '대구광역시 ' + pop.loc[~is_gunwi, 'adm_nm']



```

## (1) 배수펌프장 위치

```{python}

# 배수펌프장 데이터

#########################################################################
# 3. 재해위험지구 / 배수펌프장 데이터
# -----------------------------------------------------------------------
hazard = pd.read_csv("재해위험지역/대구광역시_재해위험지구_통합.csv", encoding="cp949")
pump = pd.read_csv("배수펌프장/대구광역시 달성군_배수펌프장_20240829.csv", encoding="cp949")
pump1 = pd.read_csv("배수펌프장/대구광역시 중구 배수펌프장정보_20201013.csv", encoding="cp949")
pump2 = pd.read_csv("배수펌프장/대구광역시_서구_배수펌프장 현황_20250716.csv", encoding="cp949")

# 펌프장 데이터 전처리 함수
def preprocess_pump(df, addr_col, name_col):
    df = df.dropna(subset=[addr_col, name_col, "위도", "경도"])
    df_renamed = df.rename(columns={name_col: "펌프장명", addr_col: "주소"})
    return df_renamed[["주소", "펌프장명", "위도", "경도"]]

pump = preprocess_pump(pump, "소재지지번주소", "배수펌프장명")
pump1 = preprocess_pump(pump1, "펌프장지번주소", "펌프장명")
pump2 = pump2.rename(columns={"소재지 지번 주소": "주소"}) # pump2 컬럼 이름 통일
pump2 = pump2.dropna(subset=["주소", "펌프장명", "위도", "경도"])

# 펌프장 데이터 합치기 + 중복 제거
pump_all = pd.concat([pump, pump1, pump2], ignore_index=True).drop_duplicates()

# GeoDataFrame으로 변환
hazard_gdf = gpd.GeoDataFrame(hazard, geometry=gpd.points_from_xy(hazard['경도'], hazard['위도']), crs="EPSG:4326")
pump_gdf = gpd.GeoDataFrame(pump_all, geometry=gpd.points_from_xy(pump_all['경도'], pump_all['위도']), crs="EPSG:4326")

#########################################################################
# 4. 행정동별 시설 개수 집계
# -----------------------------------------------------------------------
hazard_join = gpd.sjoin(hazard_gdf, geo_merged, how="left", predicate="within")
pump_join = gpd.sjoin(pump_gdf, geo_merged, how="left", predicate="within")

hazard_count = hazard_join.groupby("adm_nm").size().reset_index(name="risk_count")
pump_count = pump_join.groupby("adm_nm").size().reset_index(name="pump_count")


```

## () 대구시 내 인구 밀도에 따른 위험도 분석 - 읍면동 단위

```{python}
# 인구지도


```

```{python}
# 인구 + 배수펌프

#########################################################################
# 5. 모든 데이터 통합
# -----------------------------------------------------------------------
df = geo_merged.merge(pop[['adm_nm','인구밀도']], on="adm_nm", how="left")
df = df.merge(hazard_count, on="adm_nm", how="left")
df = df.merge(pump_count, on="adm_nm", how="left")

# 병합 후 발생할 수 있는 NaN(누락값)을 0으로 채우기
df[['인구밀도', 'risk_count', 'pump_count']] = df[['인구밀도', 'risk_count', 'pump_count']].fillna(0)

#########################################################################
# ✨ [수정 2] 안전한 정규화 (0으로 나누기 방지)
# -----------------------------------------------------------------------
for col in ['인구밀도', 'risk_count', 'pump_count']:
    min_val = df[col].min()
    max_val = df[col].max()
    
    # 최댓값과 최솟값이 같으면(모든 값이 동일하면) 분모가 0이 되므로 예외 처리
    if (max_val - min_val) > 0:
        df[col + '_norm'] = (df[col] - min_val) / (max_val - min_val)
    else:
        # 모든 값이 같을 경우 정규화 값은 0으로 설정
        df[col + '_norm'] = 0

#########################################################################
# 7. 위험 스코어 계산
# -----------------------------------------------------------------------
df['risk_score'] = 0.4 * df['인구밀도_norm'] + 0.5 * df['risk_count_norm'] - 0.1 * df['pump_count_norm']

#########################################################################
# 8. 지도 시각화
# -----------------------------------------------------------------------
m = folium.Map(location=[35.87, 128.6], zoom_start=10)

folium.Choropleth(
    geo_data=df,  # GeoDataFrame을 직접 전달하는 것을 권장
    data=df,
    columns=["adm_nm", "risk_score"],
    key_on="feature.properties.adm_nm",
    fill_color="YlOrRd",
    fill_opacity=0.7,
    line_opacity=0.5,
    legend_name="침수 위험 스코어"
).add_to(m)

# 지도 저장
m.save("대구_침수위험스코어_완성.html")

print("지도 생성이 완료되었습니다: 대구_침수위험스코어_완성.html")
```

## () 대구시 내 어린이 인구 밀도에 따른 위험도 분석 - 읍면동 단위

```{python}
# 인구지도
```

```{python}
# 인구 + 배수펌프
```

## () 대구시 내 고령자 인구 밀도에 따른 위험도 분석 - 읍면동 단위

```{python}
# 인구지도
```

```{python}
# 인구 + 배수펌프
```

## () 대구시 내 외국인 인구 밀도에 따른 위험도 분석 - 읍면동 단위

```{python}
# 인구지도
```

```{python}
# 인구 + 배수펌프
```